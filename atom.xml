<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>learn_malware</title>
  
  <subtitle>学习使我快乐，学习使我沉迷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scuzhangzhang.github.io/"/>
  <updated>2018-04-12T09:00:56.431Z</updated>
  <id>http://scuzhangzhang.github.io/</id>
  
  <author>
    <name>zwj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PE Checksum</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/PE%20checksum/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/PE checksum/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T09:00:56.431Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-check-介绍"><a href="#1-check-介绍" class="headerlink" title="1.check 介绍"></a>1.check 介绍</h3><p>PE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一个校验和，<br>所有驱动、系统启动时加载的DLL、系统关键进程加载的DLL都要进行校验和的校验，查看是否有改动，这个检验和可以通过API进行计算，CheckSumMappedFile 或者直接 MapFileAndCheckSum，计算算法比较简单如下：</p><ul><li>因为要计算整个文件数据嘛，所以开始这个字段的数据要先置0；</li><li>从文件头开始，每次读一个字（WORD），进行带进位的累加（ADC），超出WORD部分自动溢出；</li><li>将前面的累加和再加上PE文件的长度，结果就是这个校验和了</li></ul><h3 id="2-测试代码如下："><a href="#2-测试代码如下：" class="headerlink" title="2 测试代码如下："></a>2 测试代码如下：</h3><pre><code>#include&quot;stdafx.h&quot;#include &lt;windows.h&gt;#include&lt;ImageHlp.h&gt;#pragma comment(lib,&quot;ImageHlp.lib&quot;)void main(){    DWORD HeaderCheckSum = 0;   //PE头里的校验值    DWORD CheckSum = 0;     //计算下来的校验值    MapFileAndCheckSum(L&quot;D:\\newupdate.exe&quot;, &amp;HeaderCheckSum, &amp;CheckSum);    if (CheckSum == HeaderCheckSum)    {        MessageBox(NULL, L&quot;相等&quot;, NULL, 0);    }}</code></pre><h3 id="附PE可选头结构"><a href="#附PE可选头结构" class="headerlink" title="附PE可选头结构"></a>附PE可选头结构</h3><p>typedef struct _IMAGE_OPTIONAL_HEADER<br>{<br>    //<br>    // Standard fields.<br>    //<br>+18h    WORD    Magic;         // 标志字, ROM 映像（0107h）,普通可执行文件（010Bh）<br>+1Ah    BYTE      MajorLinkerVersion;     // 链接程序的主版本号<br>+1Bh    BYTE      MinorLinkerVersion;     // 链接程序的次版本号<br>+1Ch    DWORD   SizeOfCode;     // 所有含代码的节的总大小<br>+20h    DWORD   SizeOfInitializedData;    // 所有含已初始化数据的节的总大小<br>+24h    DWORD   SizeOfUninitializedData; // 所有含未初始化数据的节的大小<br>+28h    DWORD   AddressOfEntryPoint;    // 程序执行入口RVA<br>+2Ch    DWORD   BaseOfCode;      // 代码的区块的起始RVA<br>+30h    DWORD   BaseOfData;      // 数据的区块的起始RVA<br>    //<br>    // NT additional fields.    以下是属于NT结构增加的领域。<br>    //<br>+34h    DWORD   ImageBase;      // 程序的首选装载地址<br>+38h    DWORD   SectionAlignment;      // 内存中的区块的对齐大小<br>+3Ch    DWORD   FileAlignment;      // 文件中的区块的对齐大小<br>+40h    WORD    MajorOperatingSystemVersion;  // 要求操作系统最低版本号的主版本号<br>+42h    WORD    MinorOperatingSystemVersion;  // 要求操作系统最低版本号的副版本号<br>+44h    WORD    MajorImageVersion;       // 可运行于操作系统的主版本号<br>+46h    WORD    MinorImageVersion;       // 可运行于操作系统的次版本号<br>+48h    WORD    MajorSubsystemVersion;  // 要求最低子系统版本的主版本号<br>+4Ah    WORD    MinorSubsystemVersion;  // 要求最低子系统版本的次版本号<br>+4Ch    DWORD   Win32VersionValue;       // 莫须有字段，不被病毒利用的话一般为0<br>+50h    DWORD   SizeOfImage;       // 映像装入内存后的总尺寸<br>+54h    DWORD   SizeOfHeaders;       // 所有头 + 区块表的尺寸大小<br>+58h    DWORD   CheckSum;       // 映像的校检和<br>+5Ch    WORD    Subsystem;       // 可执行文件期望的子系统<br>+5Eh    WORD    DllCharacteristics;       // DllMain()函数何时被调用，默认为 0<br>+60h    DWORD   SizeOfStackReserve;       // 初始化时的栈大小<br>+64h    DWORD   SizeOfStackCommit;       // 初始化时实际提交的栈大小<br>+68h    DWORD   SizeOfHeapReserve;        // 初始化时保留的堆大小<br>+6Ch    DWORD   SizeOfHeapCommit;        // 初始化时实际提交的堆大小<br>+70h    DWORD   LoaderFlags;        // 与调试有关，默认为 0<br>+74h    DWORD   NumberOfRvaAndSizes;  // 下边数据目录的项数，这个字段自Windows NT 发布以来        // 一直是16<br>+78h    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<br>       // 数据目录表<br>} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</p><p><img src="./images/1523523098546.jpg" alt="enter description here" title="1523523098546.jpg"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-check-介绍&quot;&gt;&lt;a href=&quot;#1-check-介绍&quot; class=&quot;headerlink&quot; title=&quot;1.check 介绍&quot;&gt;&lt;/a&gt;1.check 介绍&lt;/h3&gt;&lt;p&gt;PE文件可选头结构如下，其中有个成员是checksum ，其在编译以后生成一
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 无法安装软件</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/ubuntu%20apt%E6%97%A0%E6%B3%95%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/ubuntu apt无法安装软件/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T09:12:23.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>apt-get install package 时出现以下问题</p><p>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)<br>E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p> sudo rm /var/lib/dpkg/lock<br> sudo dpkg –configure -a</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h3&gt;&lt;p&gt;apt-get install package 时出现以下问题&lt;/p&gt;
&lt;p&gt;E: Could not get lock /
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>键盘记录</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/键盘记录/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T09:08:37.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\windows\system32\msvcp_win.dll上。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>命令行下：输入sfc /scannow</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h3&gt;&lt;p&gt;win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\window
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>获取打开的文件的全路径（2）</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/%E8%8E%B7%E5%8F%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E8%B7%AF%E5%BE%84%EF%BC%882)/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/获取打开的文件的全路径（2)/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T08:48:33.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h2><p>搜索进程空间中的所有句柄，获取句柄的文件名即可。</p><h3 id="1-首先遍历进程寻找打开文件的进程，比如-word-exe-和PowerPoint-exe"><a href="#1-首先遍历进程寻找打开文件的进程，比如-word-exe-和PowerPoint-exe" class="headerlink" title="1 首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe"></a>1 首先遍历进程寻找打开文件的进程，比如 word.exe 和PowerPoint.exe</h3><pre><code>HANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);if (hSnapProcess == INVALID_HANDLE_VALUE){    return 1;}PROCESSENTRY32W ProcessEntry;ProcessEntry.dwSize = sizeof(ProcessEntry);BOOL bret = Process32FirstW(hSnapProcess, &amp;ProcessEntry);WCHAR wszProcessInfo[MAX_PATH] = { 0 };do{    WCHAR Name[MAX_PATH] = { 0 };    if (!lstrcmp(ProcessEntry.szExeFile, L&quot;POWERPNT.EXE&quot;) | !lstrcmp(ProcessEntry.szExeFile, L&quot;WINWORD.EXE&quot;))    {        …….    }</code></pre><h3 id="2-寻找到目标进程以后，获取进程中的句柄"><a href="#2-寻找到目标进程以后，获取进程中的句柄" class="headerlink" title="2  寻找到目标进程以后，获取进程中的句柄"></a>2  寻找到目标进程以后，获取进程中的句柄</h3><p> 这里利用了未文档化的一个函数</p><p>ZwQuerySystemInformation，这是ntdll.dll中的函数</p><pre><code>HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;);if (!hNtDLL){    return 1;}ZwQuerySystemInformation = (ZWQUERYSYSTEMINFORMATION)GetProcAddress(hNtDLL, &quot;ZwQuerySystemInformation&quot;);typedef NTSTATUS(WINAPI *ZWQUERYSYSTEMINFORMATION)(unsigned long, PVOID, ULONG, PULONG);ZWQUERYSYSTEMINFORMATION ZwQuerySystemInformation;</code></pre><p>函数原型如下：</p><pre><code>NTSTATUS WINAPI ZwQuerySystemInformation(  _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,  _Inout_   PVOID                    SystemInformation,  _In_      ULONG                    SystemInformationLength,  _Out_opt_ PULONG                   ReturnLength);</code></pre><p> SYSTEM_INFORMATION_CLASS结构体如下：</p><pre><code>typedef enum _SYSTEMINFOCLASS{    SystemBasicInformation,             // 0x002C    SystemProcessorInformation,         // 0x000C    SystemPerformanceInformation,       // 0x0138    SystemTimeInformation,              // 0x0020    SystemPathInformation,              // not implemented    SystemProcessInformation,           // 0x00C8+ per process    SystemCallInformation,              // 0x0018 + (n * 0x0004)    SystemConfigurationInformation,     // 0x0018    SystemProcessorCounters,            // 0x0030 per cpu    SystemGlobalFlag,                   // 0x0004 (fails if size != 4)    SystemCallTimeInformation,          // not implemented    SystemModuleInformation,            // 0x0004 + (n * 0x011C)    SystemLockInformation,              // 0x0004 + (n * 0x0024)    SystemStackTraceInformation,        // not implemented    SystemPagedPoolInformation,         // checked build only    SystemNonPagedPoolInformation,      // checked build only    SystemHandleInformation,            // 0x0004  + (n * 0x0010)    SystemObjectTypeInformation,        // 0x0038+ + (n * 0x0030+)    SystemPageFileInformation,          // 0x0018+ per page file    SystemVdmInstemulInformation,       // 0x0088    SystemVdmBopInformation,            // invalid info class    SystemCacheInformation,             // 0x0024    SystemPoolTagInformation,           // 0x0004 + (n * 0x001C)    SystemInterruptInformation,         // 0x0000, or 0x0018 per cpu    SystemDpcInformation,               // 0x0014    SystemFullMemoryInformation,        // checked build only    SystemLoadDriver,                   // 0x0018, set mode only    SystemUnloadDriver,                 // 0x0004, set mode only    SystemTimeAdjustmentInformation,    // 0x000C, 0x0008 writeable    SystemSummaryMemoryInformation,     // checked build only    SystemNextEventIdInformation,       // checked build only    SystemEventIdsInformation,          // checked build only    SystemCrashDumpInformation,         // 0x0004    SystemExceptionInformation,         // 0x0010    SystemCrashDumpStateInformation,    // 0x0004    SystemDebuggerInformation,          // 0x0002    SystemContextSwitchInformation,     // 0x0030    SystemRegistryQuotaInformation,     // 0x000C    SystemAddDriver,                    // 0x0008, set mode only    SystemPrioritySeparationInformation,// 0x0004, set mode only    SystemPlugPlayBusInformation,       // not implemented    SystemDockInformation,              // not implemented    SystemPowerInfo,             // 0x0060 (XP only!)    SystemProcessorSpeedInformation,    // 0x000C (XP only!)    SystemTimeZoneInformation,          // 0x00AC    SystemLookasideInformation,         // n * 0x0020    SystemSetTimeSlipEvent,    SystemCreateSession,    // set mode only    SystemDeleteSession,    // set mode only    SystemInvalidInfoClass1,   // invalid info class    SystemRangeStartInformation,   // 0x0004 (fails if size != 4)    SystemVerifierInformation,    SystemAddVerifier,    SystemSessionProcessesInformation, // checked build only    MaxSystemInfoClass} SYSTEMINFOCLASS, *PSYSTEMINFOCLASS;</code></pre><p>这个结构再MSDN上只列举了一部分，这是网上搜索的结构，可以访问<a href="http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm查看详细的信息，其包含了我们所需要的一个参数SystemHandleInformation" target="_blank" rel="external">http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/sysinfo/query.htm查看详细的信息，其包含了我们所需要的一个参数SystemHandleInformation</a>  用来获取系统中进程的句柄信息，第二个参数是缓冲区指针，第三个参数是大小，最后一个参数是实际的返回的数据大小。<br>传入SystemHandleInformation   将会返回一个SYSTEM_HANDLE_INFORMATION结构，结构如下：</p><pre><code>typedef struct _SYSTEM_HANDLE_INFORMATION{    ULONG   uCount;    SYSTEM_HANDLE aSH[];} SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;typedef struct _SYSTEM_HANDLE{    ULONG  uIdProcess;    UCHAR  ObjectType;    // OB_TYPE_* (OB_TYPE_TYPE, etc.)    UCHAR  Flags;         // HANDLE_FLAG_* (HANDLE_FLAG_INHERIT, etc.)    USHORT  Handle;    PVOID  pObject;    ACCESS_MASK GrantedAccess;} SYSTEM_HANDLE, *PSYSTEM_HANDLE;</code></pre><h3 id="3-查找句柄对应的进程，获取句柄对应的文件名"><a href="#3-查找句柄对应的进程，获取句柄对应的文件名" class="headerlink" title="3 查找句柄对应的进程，获取句柄对应的文件名"></a>3 查找句柄对应的进程，获取句柄对应的文件名</h3><p>通过查询返回句柄的进程pid与传入的PID比较。若符合，OpenProcess 打开该进程，DuplicateHanle复制句柄，然后获取句柄的文件名，然后相对路径转换为绝对路径。<br>获取句柄的详细信息用到了ZwQueryInformationFile 函数，这个函数同样是一个未文档化的函数，</p><pre><code>HMODULE hNtDLL = LoadLibrary(L&quot;NTDLL.DLL&quot;);if (!hNtDLL){    return 1;}ZwQueryInformationFile = (ZWQUERYINFORMATIONFILE)GetProcAddress(hNtDLL, &quot;ZwQueryInformationFile&quot;);typedef NTSTATUS(WINAPI *ZWQUERYINFORMATIONFILE)(HANDLE, PIO_STATUS_BLOCK, PVOID,ULONG, FILE_INFORMATION_CLASS);ZWQUERYINFORMATIONFILE ZwQueryInformationFile;NTSTATUS   ZwQueryInformationFile(    IN HANDLE  FileHandle,    OUT PIO_STATUS_BLOCK  IoStatusBlock,    OUT PVOID  FileInformation,    IN ULONG  Length,    IN FILE_INFORMATION_CLASS  FileInformationClass    );</code></pre><p>第一个参数是文件句柄，第二个参数是接收最终完成状态的IO_STATUS_BLOCK结构的指针。第三个参数是存储返回的文件对象的信息，第四个参数是缓冲区大小，第五个参数是文件信息的类型，我们传入FileNameInformation。在这里我们定义了一个结构体 PNM_INFO ，用来存储信息</p><pre><code>typedef struct _NM_INFO{    HANDLE  hFile;    FILE_NAME_INFORMATION Info;    WCHAR Name[MAX_PATH];} NM_INFO, *PNM_INFO;</code></pre><p>第三个成员即为文件名包括路径，不过是相对路径，调用 PathResolve<br> 获取绝对路径。到此文件的全路径就获取到了。<br>代码地址如下：<br><a href="https://github.com/scuzhangzhang/GetFileFullPath/tree/master/GetFileFullPath" target="_blank" rel="external">https://github.com/scuzhangzhang/GetFileFullPath/tree/master/GetFileFullPath</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方法二：&quot;&gt;&lt;a href=&quot;#方法二：&quot; class=&quot;headerlink&quot; title=&quot;方法二：&quot;&gt;&lt;/a&gt;方法二：&lt;/h2&gt;&lt;p&gt;搜索进程空间中的所有句柄，获取句柄的文件名即可。&lt;/p&gt;
&lt;h3 id=&quot;1-首先遍历进程寻找打开文件的进程，比如-word
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>获取打开文件的全路径（1）</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/%E8%8E%B7%E5%8F%96%E6%89%93%E5%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E8%B7%AF%E5%BE%84%EF%BC%881%EF%BC%89/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/获取打开的文件的全路径（1）/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T08:49:47.301Z</updated>
    
    <content type="html"><![CDATA[<p>方法一：（后续参见方法二）</p><p>获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）<br>步骤：<br>1 遍历进程获取打开文件的可执行文件的进程</p><pre><code>HANDLE hSnapProcess = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);if (hSnapProcess == INVALID_HANDLE_VALUE){    return;}PROCESSENTRY32W ProcessEntry;ProcessEntry.dwSize = sizeof(ProcessEntry);BOOL bret = Process32FirstW(hSnapProcess, &amp;ProcessEntry);WCHAR wszProcessInfo[MAX_PATH] = { 0 };do{    WCHAR Name[MAX_PATH] = { 0 };    if (!lstrcmp(ProcessEntry.szExeFile, L&quot;POWERPNT.EXE&quot;)| !lstrcmp(ProcessEntry.szExeFile, L&quot;WINWORD.EXE&quot;))    {        HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, false, ProcessEntry.th32ProcessID);        do something        CloseHandle(hProcess);    }} while (Process32NextW(hSnapProcess, &amp;ProcessEntry));</code></pre><p> 2  利用ntdll.dll中一个未公开的函数NtQueryInformationProcess，获取进程信息然后去读对方进程ReadProcessMemory,函数原型如下：</p><pre><code>NTSTATUS WINAPI NtQueryInformationProcess(  _In_      HANDLE           ProcessHandle,  _In_      PROCESSINFOCLASS ProcessInformationClass,  _Out_     PVOID            ProcessInformation,  _In_      ULONG            ProcessInformationLength,  _Out_opt_ PULONG           ReturnLength);</code></pre><p>第一个参数是进程句柄，第二个参数是获取的进程的信息类型，这里我们选择ProcessBasicInformation,<br>msdn 的声明如下，会返回一个PEB结构体。</p><p><img src="./images/1523522947070.jpg" alt="enter description here" title="1523522947070.jpg"></p><p>第三个参数是输出参数，当参数2是ProcessBasicInformation时，会返回一个<br>PROCESS_BASIC_INFORMATION 结构，结构如下，</p><p><img src="./images/1523522975322.jpg" alt="enter description here" title="1523522975322.jpg"></p><pre><code>status = NtQueryInformationProcess(hProcess,                ProcessBasicInformation,                &amp;pbi,                sizeof(PROCESS_BASIC_INFORMATION),                &amp;ReturnLength);</code></pre><p>3  获取到PROCESS_BASIC_INFORMATION结构体以后，由上可以看出的它的第二个成员就是指向进程PEB结构体的指针，此时调用ReadProcessMemory，获取进程PEB，</p><pre><code> ReadProcessMemory(hProcess, pbi.PebBaseAddress, &amp;peb, sizeof(PEB), 0)  ReadProcessMemory的函数原型如下：BOOL WINAPI ReadProcessMemory(  _In_  HANDLE  hProcess,  _In_  LPCVOID lpBaseAddress,  _Out_ LPVOID  lpBuffer,  _In_  SIZE_T  nSize,  _Out_ SIZE_T  *lpNumberOfBytesRead);</code></pre><p>4.通过ReadProcessMemory 获取进程的PEB以后，PEB的结构如下：</p><pre><code>typedef struct _PEB {    BOOLEAN                 InheritedAddressSpace;    BOOLEAN                 ReadImageFileExecOptions;    BOOLEAN                 BeingDebugged;    BOOLEAN                 Spare;    HANDLE                  Mutant;    PVOID                   ImageBaseAddress;    PPEB_LDR_DATA           LoaderData;    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;    PVOID                   SubSystemData;    PVOID                   ProcessHeap;    PVOID                   FastPebLock;    PPEBLOCKROUTINE         FastPebLockRoutine;    PPEBLOCKROUTINE         FastPebUnlockRoutine;    ULONG                   EnvironmentUpdateCount;    PVOID*                  KernelCallbackTable;    PVOID                   EventLogSection;    PVOID                   EventLog;    PPEB_FREE_BLOCK         FreeList;    ULONG                   TlsExpansionCounter;    PVOID                   TlsBitmap;    ULONG                   TlsBitmapBits[0x2];    PVOID                   ReadOnlySharedMemoryBase;    PVOID                   ReadOnlySharedMemoryHeap;    PVOID*                  ReadOnlyStaticServerData;    PVOID                   AnsiCodePageData;    PVOID                   OemCodePageData;    PVOID                   UnicodeCaseTableData;    ULONG                   NumberOfProcessors;    ULONG                   NtGlobalFlag;    BYTE                    Spare2[0x4];    LARGE_INTEGER           CriticalSectionTimeout;    ULONG                   HeapSegmentReserve;    ULONG                   HeapSegmentCommit;    ULONG                   HeapDeCommitTotalFreeThreshold;    ULONG                   HeapDeCommitFreeBlockThreshold;    ULONG                   NumberOfHeaps;    ULONG                   MaximumNumberOfHeaps;    PVOID*                  *ProcessHeaps;    PVOID                   GdiSharedHandleTable;    PVOID                   ProcessStarterHelper;    PVOID                   GdiDCAttributeList;    PVOID                   LoaderLock;    ULONG                   OSMajorVersion;    ULONG                   OSMinorVersion;    ULONG                   OSBuildNumber;    ULONG                   OSPlatformId;    ULONG                   ImageSubSystem;    ULONG                   ImageSubSystemMajorVersion;    ULONG                   ImageSubSystemMinorVersion;    ULONG                   GdiHandleBuffer[0x22];    ULONG                   PostProcessInitRoutine;    ULONG                   TlsExpansionBitmap;    BYTE                    TlsExpansionBitmapBits[0x80];    ULONG                   SessionId;} PEB, *PPEB;</code></pre><p>如图标红位置为进程的参数信息，再次调用ReadProcessMemory  获取参数信息，<br>ReadProcessMemory(hProcess, peb.ProcessParameters, &amp;upps, sizeof(RTL_USER_PROCESS_PARAMETERS), 0))<br> 其中upps是一个RTL_USER_PROCESS_PARAMETERS 的结构体，定义如下：<br>    typedef struct _RTL_USER_PROCESS_PARAMETERS<br>    {<br>        ULONG MaximumLength;<br>        ULONG Length;</p><pre><code>    ULONG Flags;    ULONG DebugFlags;    HANDLE ConsoleHandle;    ULONG ConsoleFlags;    HANDLE StandardInput;    HANDLE StandardOutput;    HANDLE StandardError;    CURDIR CurrentDirectory;    UNICODE_STRING DllPath;    UNICODE_STRING ImagePathName;    UNICODE_STRING CommandLine;    PVOID Environment;    ULONG StartingX;    ULONG StartingY;    ULONG CountX;    ULONG CountY;    ULONG CountCharsX;    ULONG CountCharsY;    ULONG FillAttribute;    ULONG WindowFlags;    ULONG ShowWindowFlags;    UNICODE_STRING WindowTitle;    UNICODE_STRING DesktopInfo;    UNICODE_STRING ShellInfo;    UNICODE_STRING RuntimeData;    RTL_DRIVE_LETTER_CURDIR CurrentDirectories[RTL_MAX_DRIVE_LETTERS];    ULONG EnvironmentSize;    ULONG EnvironmentVersion;    PVOID PackageDependencyData; //8+    ULONG ProcessGroupId;   // ULONG LoaderThreads;} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;</code></pre><p>如上标红位置为命令行信息，UNICODE_STRING同样是一个结构体，定义如下：</p><pre><code>typedef struct _UNICODE_STRING {    USHORT Length;    USHORT MaximumLength;    PWSTR  Buffer;} UNICODE_STRING;typedef UNICODE_STRING *PUNICODE_STRING;</code></pre><p>再次调用ReadProcessMemory获取命令行字符串信息，存入buffer中</p><pre><code>ReadProcessMemory(hProcess, upps.CommandLine.Buffer, buffer, upps.CommandLine.Length, 0); </code></pre><p>到这完整的进程命令行信息就获取到了。通过字符串处理就可以得到相应的打开的文件的全路径了 。</p><p>代码工程链接：<a href="https://github.com/scuzhangzhang/GetFileFullPath" target="_blank" rel="external">https://github.com/scuzhangzhang/GetFileFullPath</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;方法一：（后续参见方法二）&lt;/p&gt;
&lt;p&gt;获取进程PEB中的命令行参数信息（问题：如果先打开文件比如word.exe再打开文件，会出现获取不到的情况）&lt;br&gt;步骤：&lt;br&gt;1 遍历进程获取打开文件的可执行文件的进程&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HANDLE hSnapPr
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>windows 更新以后无法定位msvcp_win.dll</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/windows%E6%9B%B4%E6%96%B0%E5%87%BA%E7%8E%B0%E6%97%A0%E6%B3%95%E5%AE%9A%E4%BD%8Ddll%E9%97%AE%E9%A2%98/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/windows更新出现无法定位dll问题/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T09:07:08.397Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\windows\system32\msvcp_win.dll上。</p><h3 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h3><p>命令行下：输入sfc /scannow</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题描述：&quot;&gt;&lt;a href=&quot;#问题描述：&quot; class=&quot;headerlink&quot; title=&quot;问题描述：&quot;&gt;&lt;/a&gt;问题描述：&lt;/h3&gt;&lt;p&gt;win10更新以后出现 无法定位程序输入点_uncaught_exceptions 于动态链接库 C:\window
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>windows 编程获取网卡和ip</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/windows%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E7%BD%91%E5%8D%A1%E5%92%8CIP/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/windows编程获取网卡和IP/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T02:41:16.635Z</updated>
    
    <content type="html"><![CDATA[<p>一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP_ADAPTER_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示：</p><pre><code>            typedef struct _IP_ADAPTER_INFO {            struct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针            DWORD ComboIndex;//预留值            char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称            char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述            UINT AddressLength;//适配器硬件地址以字节计算的长度            BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示            DWORD Index;//适配器索引                    UINT Type;//适配器类型,主要有以下几种：                    /*                    *   MIB_IF_TYPE_OTHER     1                    *   MIB_IF_TYPE_ETHERNET     6                    *   MIB_IF_TYPE_TOKENRING     9                    *   MIB_IF_TYPE_FDDI     15                    *   MIB_IF_TYPE_PPP     23                    *   MIB_IF_TYPE_LOOPBACK      24                    *   MIB_IF_TYPE_SLIP      28                    */            UINT DhcpEnabled;//指定这个适配器是否开启DHCP            PIP_ADDR_STRING CurrentIpAddress;//预留值            IP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表            IP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表            IP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表            BOOL HaveWins;            IP_ADDR_STRING PrimaryWinsServer;            IP_ADDR_STRING SecondaryWinsServer;            time_t LeaseObtained;            time_t LeaseExpires;            } IP_ADAPTER_INFO,*PIP_ADAPTER_INFO;由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示：    typedef struct _IP_ADDR_STRING    {            struct _IP_ADDR_STRING* Next;  //指向同类型节点，即下一个IP（如果有多IP的话）            IP_ADDRESS_STRING IpAddress;  //IP地址信息            IP_MASK_STRING IpMask; //IP子网掩码            DWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数    } IP_ADDR_STRING;</code></pre><p>在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示：</p><pre><code>#include &lt;WinSock2.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;iostream&gt;using namespace std;#pragma comment(lib,&quot;Iphlpapi.lib&quot;) //需要添加Iphlpapi.lib库int main(int argc, char* argv[]){        //PIP_ADAPTER_INFO结构体指针存储本机网卡信息        PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();        //得到结构体大小,用于GetAdaptersInfo参数        unsigned long stSize = sizeof(IP_ADAPTER_INFO);        //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量        int nRel = GetAdaptersInfo(pIpAdapterInfo,&amp;stSize);        //记录网卡数量        int netCardNum = 0;        //记录每张网卡上的IP地址数量        int IPnumPerNetCard = 0;        if (ERROR_BUFFER_OVERFLOW == nRel)        {                //如果函数返回的是ERROR_BUFFER_OVERFLOW                //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小                //这也是说明为什么stSize既是一个输入量也是一个输出量                //释放原来的内存空间                delete pIpAdapterInfo;                //重新申请内存空间用来存储所有网卡信息                pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];                //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量                nRel=GetAdaptersInfo(pIpAdapterInfo,&amp;stSize);            }        if (ERROR_SUCCESS == nRel)        {                //输出网卡信息                //可能有多网卡,因此通过循环去判断        while (pIpAdapterInfo)        {                cout&lt;&lt;&quot;网卡数量：&quot;&lt;&lt;++netCardNum&lt;&lt;endl;                cout&lt;&lt;&quot;网卡名称：&quot;&lt;&lt;pIpAdapterInfo-&gt;AdapterName&lt;&lt;endl;                cout&lt;&lt;&quot;网卡描述：&quot;&lt;&lt;pIpAdapterInfo-&gt;Description&lt;&lt;endl;                switch(pIpAdapterInfo-&gt;Type)                {                case MIB_IF_TYPE_OTHER:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;OTHER&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_ETHERNET:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;ETHERNET&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_TOKENRING:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;TOKENRING&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_FDDI:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;FDDI&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_PPP:                        printf(&quot;PP\n&quot;);                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;PPP&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_LOOPBACK:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;LOOPBACK&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_SLIP:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;SLIP&quot;&lt;&lt;endl;                        break;                default:break;                }                cout&lt;&lt;&quot;网卡MAC地址：&quot;;                for (DWORD i = 0; i &lt; pIpAdapterInfo-&gt;AddressLength; i++)                        if (i &lt; pIpAdapterInfo-&gt;AddressLength-1)                        {                                printf(&quot;%02X-&quot;, pIpAdapterInfo-&gt;Address[i]);                        }                        else                        {                                printf(&quot;%02X\n&quot;, pIpAdapterInfo-&gt;Address[i]);                        }                        cout&lt;&lt;&quot;网卡IP地址如下：&quot;&lt;&lt;endl;                        //可能网卡有多IP,因此通过循环去判断                        IP_ADDR_STRING *pIpAddrString =&amp;(pIpAdapterInfo-&gt;IpAddressList);                        do                         {                                cout&lt;&lt;&quot;该网卡上的IP数量：&quot;&lt;&lt;++IPnumPerNetCard&lt;&lt;endl;                                cout&lt;&lt;&quot;IP 地址：&quot;&lt;&lt;pIpAddrString-&gt;IpAddress.String&lt;&lt;endl;                                cout&lt;&lt;&quot;子网地址：&quot;&lt;&lt;pIpAddrString-&gt;IpMask.String&lt;&lt;endl;                                cout&lt;&lt;&quot;网关地址：&quot;&lt;&lt;pIpAdapterInfo-&gt;GatewayList.IpAddress.String&lt;&lt;endl;                                pIpAddrString=pIpAddrString-&gt;Next;                        } while (pIpAddrString);                        pIpAdapterInfo = pIpAdapterInfo-&gt;Next;                        cout&lt;&lt;&quot;--------------------------------------------------------------------&quot;&lt;&lt;endl;        }        }        //释放内存空间        if (pIpAdapterInfo)        {                delete pIpAdapterInfo;        }        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>IDA创建结构体</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/IDA%E5%88%9B%E5%BB%BA%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/IDA创建结构体/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T09:21:45.381Z</updated>
    
    <content type="html"><![CDATA[<p>1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入</p><h1 id="enter-description-here-1"><a href="#enter-description-here-1" class="headerlink" title="![enter description here][1]"></a>![enter description here][1]</h1><p>  [1]: ./images/1523524566543.jpg “”<br>  2.在ends 后按d键，添加相应的成员，然后选中成员名，按N进行修改，选中类型，按d 进行更改类型，构造完结构题以后，回到代码窗口</p><h1 id="enter-description-here-1-1"><a href="#enter-description-here-1-1" class="headerlink" title="![enter description here][1]"></a>![enter description here][1]</h1><p>  [1]: ./images/1523524736757.jpg “”</p><p>  3  在代码窗口找到相应的变量，右键选择Convert to struct ，然后选择刚刚你定义的结构体即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.在IDA中打开Structures，快捷键是shifr+ F9 ,然后按insert键，进行插入&lt;/p&gt;
&lt;h1 id=&quot;enter-description-here-1&quot;&gt;&lt;a href=&quot;#enter-description-here-1&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>php操作文件</title>
    <link href="http://scuzhangzhang.github.io/2017/12/12/php%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/"/>
    <id>http://scuzhangzhang.github.io/2017/12/12/php操作文件/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2017-12-12T02:36:30.129Z</updated>
    
    <content type="html"><![CDATA[<p>一.问题阐述<br>        php 脚本中实现对文件的修改，压缩。</p><p>二.解决办法</p><pre><code>1.修改文件的权限为777(新手勿喷)  chmod 777 filename2.修改压缩命令的权限 首先找到压缩命令的位置 sudo find / -name tar 发现在/bin/tar 然后赋予权限 chmod 4777 /bin/tar 4777中4代表赋予文件所有者的权限 此时就可以对文件进行修改然后打包了。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一.问题阐述&lt;br&gt;        php 脚本中实现对文件的修改，压缩。&lt;/p&gt;
&lt;p&gt;二.解决办法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.修改文件的权限为777(新手勿喷)
  chmod 777 filename
2.修改压缩命令的权限
 首先找到压缩命令的位置
 sud
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>linux usb wifi设置AP 模式</title>
    <link href="http://scuzhangzhang.github.io/2017/12/12/ubuntu16.04%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87usb%20wifi%20%E6%95%A3%E7%83%AD%E7%82%B9/"/>
    <id>http://scuzhangzhang.github.io/2017/12/12/ubuntu16.04系统通过usb wifi 散热点/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2017-12-12T02:30:58.048Z</updated>
    
    <content type="html"><![CDATA[<p>一.问题阐述<br>        本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。</p><p>二.解决办法</p><pre><code> 第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。 第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下： 1.卸载已有的hostapd sudo apt-get autoremove hostapd 2.下载带有rtl8188eu的源码。 wget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz tar -zxvf v2.0.tar.gz 3.编译 cd RTL8188-hostapd-2.0/hostapd sudo make 4.安装 sudo  make install此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。参考链接：https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pihttp://os.51cto.com/art/201311/415573.htm</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一.问题阐述&lt;br&gt;        本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。&lt;/p&gt;
&lt;p&gt;二.解决
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04 解决apt-get install 安装失败的问题</title>
    <link href="http://scuzhangzhang.github.io/2017/12/05/ubuntu16.04%20%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://scuzhangzhang.github.io/2017/12/05/ubuntu16.04 解决安装包问题/</id>
    <published>2017-12-04T16:00:00.000Z</published>
    <updated>2017-12-05T09:50:12.657Z</updated>
    
    <content type="html"><![CDATA[<p>1.问题描述：apt-get install 特别慢，几乎不动</p><pre><code>常规的解决办法就是去换源，记得换源之后apt-get update 一般都会得到解决，</code></pre><p>2.由于我的机器当时设置的有翻墙全局代理，所以当我apt-get update 的时候速度非常慢，记得你换源的目的是为了用国内源，增加速度，当你处于全局代理的情况下，从国外访问国内然后再更新，肯定速度会很慢啊，然后无论你换国内的什么源都是一样的。记得关掉。<br>注意:一般翻墙代理都要设置iptables NAT规则，清楚的命令为 iptables -t NAT -F 可以清楚NAT 的规则<br> 对于有些Linux系统，iptables -F不能清除NAT的规则</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.问题描述：apt-get install 特别慢，几乎不动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常规的解决办法就是去换源，记得换源之后apt-get update 
一般都会得到解决，
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.由于我的机器当时设置的有翻墙全局代理，所以当我apt-
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>WIN10 linux 子系统安装lamp</title>
    <link href="http://scuzhangzhang.github.io/2017/11/29/win10linux%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85LAMP/"/>
    <id>http://scuzhangzhang.github.io/2017/11/29/win10linux 子系统安装LAMP/</id>
    <published>2017-11-28T16:00:00.000Z</published>
    <updated>2017-11-29T14:08:55.197Z</updated>
    
    <content type="html"><![CDATA[<p>1.换源</p><pre><code>备份原先的源cp /etc/apt/sources.list /etc/apt/sources.list.bakvim /etc/apt/sources.list换成deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse更新apt-get update    </code></pre><p>2.安装apache2</p><pre><code>apt-get install apache2service apache2 restart 在本地浏览器打开localhost 应该可以看到apache2的欢迎界面</code></pre><p>3.安装php</p><pre><code>按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子我找的解决办法是如下：apt-get install software-properties-commonadd-apt-repository ppa:ondrej/phpapt-get updateapt-get install phpapt-get install libapache2-mod-phpservice apache2 restart</code></pre><p>4.测试php</p><pre><code>在/var/www/html目录下新建test.php内容如下：&lt;?phpphpinfo();?&gt;打开localhost/test.php 正常显示则代表成功</code></pre><p>5.至于mysql 的安装，后续再写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.换源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;备份原先的源
cp /etc/apt/sources.list /etc/apt/sources.list.bak
vim /etc/apt/sources.list
换成
deb http://mirrors.aliyun.com/
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>dns污染的解决</title>
    <link href="http://scuzhangzhang.github.io/2017/11/15/dns%E6%B1%A1%E6%9F%93%E8%A7%A3%E5%86%B3/"/>
    <id>http://scuzhangzhang.github.io/2017/11/15/dns污染解决/</id>
    <published>2017-11-14T16:00:00.000Z</published>
    <updated>2017-11-22T11:19:58.450Z</updated>
    
    <content type="html"><![CDATA[<p>dnsmasq+chinadns+hev-dns-forwarder</p><p>1.安装dnsmasq</p><pre><code>sudo apt-get install dnsmasq编辑/etc/dnsmasq.conf 取消no-resolv前面的注释server=127.0.0.1#5354</code></pre><p>2.安装chindns<br>    <a href="https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz" target="_blank" rel="external">https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz</a><br>    解压<br>    tar -zxf chinadns-1.3.2.tar.gz<br>    cd chinadns-1.3.2<br>    ./configure<br>    make<br>    make install<br>    安装结束后在复制到/usr/local/bin 目录中去（可能已经自动复制到了，确认一下）<br>    运行命令为<br>    chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  &amp; &gt; /dev/null 2&gt;&amp;1</p><p>3.安装</p><pre><code>git clone https://github.com/aa65535/hev-dns-forwardercd hev-dns-forwardermake编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下运行命令hev-dns-forwarder</code></pre><p>4.加入开机启动项</p><pre><code>在/etc/rc.local中加入sudo  hev-dns-forwarder  &amp; &gt; /dev/null 2&gt;&amp;1sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  &amp; &gt; /dev/null 2&gt;&amp;1</code></pre><p>参考链接：<br><a href="https://blog.bluerain.io/p/SS-Redir-For-Router.html" target="_blank" rel="external">https://blog.bluerain.io/p/SS-Redir-For-Router.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dnsmasq+chinadns+hev-dns-forwarder&lt;/p&gt;
&lt;p&gt;1.安装dnsmasq&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install dnsmasq
编辑/etc/dnsmasq.conf 
取消no-resolv前面的注释
s
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>web界面编写</title>
    <link href="http://scuzhangzhang.github.io/2017/11/14/web%E7%95%8C%E9%9D%A2/"/>
    <id>http://scuzhangzhang.github.io/2017/11/14/web界面/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-11-15T03:56:23.891Z</updated>
    
    <content type="html"><![CDATA[<p>1.为树莓派设置wifi静态ip</p><pre><code>sudo vim /etc/dhcpcd.conf加入interface wlan0inform 192.168.1.1</code></pre><p>2.安装apache2和php</p><pre><code>sudo apt-get install apache2sudo apt-get install php5</code></pre><p>3.apache默认的web目录为/var/www/html</p><pre><code>把你写的html，php,js，css文件放入该目录</code></pre><p>4.我主要是为了登陆树莓派设置一个静态IP，代码如下<br>    setip.html</p><pre><code>&lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;设置页面&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;config.css&quot;/&gt;   &lt;/head&gt;  &lt;body&gt;&lt;div id=&quot;config_frame&quot;&gt;      &lt;p style=&quot;color:#0C5391;&quot; id=&quot;image_logo&quot;&gt;设置ip&lt;/p&gt;     &lt;form action=&quot;setip.php&quot; method=&quot;get&quot; id=&quot;form_control&quot; enctype=&quot;multi-part/form-data&quot;&gt;          &lt;div id=&quot;login_control&quot; style=&quot;text-align: center;&quot; &gt;              &lt;input  name=&quot;ip&quot; type=&quot;text&quot; id=&quot;ip&quot;  class=&quot;text_field&quot; &gt;        &lt;/div&gt;        &lt;br&gt;        &lt;br&gt;        &lt;br&gt;        &lt;div style=&quot;text-align: center;&quot; &gt;                 &lt;input type=&quot;submit&quot;&gt;        &lt;/div&gt;         &lt;div style=&quot;text-align: center;&quot; &gt;                     &lt;p  &gt;&lt;label id=&quot;log&quot; class=&quot;label&quot;&gt;&lt;/label&gt;&lt;/p&gt;         &lt;/div&gt;     &lt;/form&gt;  &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;setip.php&lt;?phpini_set(&quot;display_errors&quot;, &quot;On&quot;); error_reporting(E_ALL | E_STRICT);$arr = file(&quot;/etc/dhcpcd.conf&quot;);//echo $arr[count($arr)-1];$ip = $_GET[&apos;ip&apos;];//echo (&quot;inform&quot;.&quot;  &quot;.$ip);$data=&quot;inform&quot;.&quot;  &quot;.$ip;$arr[count($arr)-1]=$data;//echo $arr[count($arr)-1];file_put_contents(&apos;/etc/dhcpcd.conf&apos;, $arr);?&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;config.css&quot;/&gt;   &lt;/head&gt;  &lt;body&gt;&lt;script&gt;alert(&quot;设置成功，请重启&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.为树莓派设置wifi静态ip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/dhcpcd.conf
加入
interface wlan0
inform 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.安装apache2和php&lt;/p&gt;
&lt;pre&gt;
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>树莓派搭建vpn服务器</title>
    <link href="http://scuzhangzhang.github.io/2017/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAvpn%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://scuzhangzhang.github.io/2017/11/11/树莓派搭建vpn服务器/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2017-11-29T14:05:30.682Z</updated>
    
    <content type="html"><![CDATA[<p>1.此篇是在前篇搭建树莓派透明网管的基础上完成的，有兴趣的可以去看看</p><pre><code>[树莓派透明代理](http://scuzwj.xyz/2017/10/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/)</code></pre><p>2.树莓派尽量设置成静态ip，具体如下</p><pre><code>sudo vim /etc/dhcpcd.conf填写以下内容interface eth0static ip_address=ipstatic routers=网关static domain_name_servers=223.5.5.5</code></pre><p>3.安装openvpn</p><pre><code>sudo apt-get install openvpn</code></pre><p>4.下载easy-rsa</p><pre><code>cd /etc/openvpnwget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgztar -xzvf EasyRSA-2.2.2.tgzmv EasyRSA-2.2.2 easy-rsa</code></pre><p>5.配置easy-rsa</p><pre><code>cd /etc/openvpn/easy-rsavim vars    # 打开easy-rsa配置文件修改一下内容export EASY_RSA=&quot;/etc/openvpn/easy-rsa&quot;export KEY_SIZE=1024 #默认的2048太大，要运算很久加载配置source ./vars</code></pre><p>6.生成ca密钥</p><pre><code>./clean-all      # 先清空所有密钥./build-ca       # 创建自己的证书所有内容直接回车就可以了。这时keys文件夹下会多了ca.crt,和ca.key文件</code></pre><p>7.生成服务器密钥</p><pre><code>./build-key-server servername # servername为你自己设置的服务器名字会出现很多让填写的地方，注意下面三个其他的默认就好Common Name 常用名必须是你方才所设置的服务器名，默认设置如此。A challenge password? 网上说必须留空，我也照办了，不晓得为什么Sign the certificate? [y/n] 必须填y</code></pre><p>8.生成客户端密钥</p><pre><code>./build-key-pass client1   # 命令中client1是客户端的名字Enter PEM pass phrase 这个要记住，这是客户端使用vpn时的密码，会让输入两次。这时keys下又会多出三个文件client1.csr client1.crt client.key</code></pre><p>9.生成dh</p><pre><code>./build-dh到此密钥生成部分就完成了。</code></pre><p>10.openvpn 服务器配置    </p><pre><code># 复制一个模板过来先cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.confvim /etc/openvpn/server.conf下面是我的配置port 1194   #Openvpn服务使用的端口proto tcp   #使用udp协议传输dev tun     #使用隧道ca /etc/openvpn/easy-rsa/keys/ca.crt        #ca公钥路径cert /etc/openvpn/easy-rsa/keys/server.crt  #服务器公钥路径key /etc/openvpn/easy-rsa/keys/server.key   #服务器私钥路径dh /etc/openvpn/easy-rsa/keys/dh1024.pem    #dhserver 10.10.20.0 255.255.255.0   #客户端连接后，所在的子网段ifconfig-pool-persist ipp.txt   #客户端使用固定的子网地址，这里可以不配置push &quot;redirect-gateway def1 bypass-dhcp&quot;    #网关重定向，客户端的流量都会经由OpenvpnServer#配置DNSpush &quot;dhcp-option DNS 202.141.162.123&quot;push &quot;dhcp-option DNS 202.38.93.153 client-to-clientduplicate-cn    #允许客户端的CommonName重复，因为我们填的都是默认值keepalive 10 120comp-lzo    #启动数据压缩user nobody     #Openvpn进程运行时所属的用户，这里为了安全group nogroup   #Openvpn进程运行时所属的组，这里为了安全persist-key     #一直保存key，避免权限问题导致不能再次读取persist-tun     #一直保持隧道，原因同上status /etc/openvpn/easy-rsa/keys/openvpn-status.log   #Openvpn运行状态Log，就在Openvpn目录下，会自动生成log openvpn.log             #Openvpn运行Log，也在Openvpn目录下，会自动生成verb 3                      #log的等级</code></pre><p>11.此时可以测试一下了</p><pre><code>openvpn server.confservice openvpn restart不报错就是成功了</code></pre><p>12.客户端配置</p><pre><code>cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/clientconfig/client.confvim /etc/openvpn/clientconfig/client.conf我的配置如下：# 里面注释也很详细，这里贴出我精简后的结果client      #标明是客户端配置dev tun     #使用隧道proto tcp   #使用UDPremote 192.168.19.149 1194   #树莓派外网IP（使用动态域名绑定） + 端口comp-lzo        ca ca.crt       #ca公钥cert wxlnb.crt  #客户端公钥key wxlnb.key   #客户端私钥verb 3  #log等级</code></pre><p>13.防火墙规则我就改了一点</p><pre><code>iptables -t nat -A PREROUTING -i tun0 -p tcp -j REDSOCKS</code></pre><p>14.测试</p><pre><code>在其他Windows机器上，下载openvpn 安装，然后把ca.crt,client.conf（就是刚刚那个client.conf）,client1.crt,client1.key复制到config 文件夹下。</code></pre><p>参考链接</p><pre><code>1.http://www.smartmcu.com/article-246-1.html2.http://blog.csdn.net/wxlguitar/article/details/51175872</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.此篇是在前篇搭建树莓派透明网管的基础上完成的，有兴趣的可以去看看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[树莓派透明代理](http://scuzwj.xyz/2017/10/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后hexo 博客恢复</title>
    <link href="http://scuzhangzhang.github.io/2017/11/05/hexo%20%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"/>
    <id>http://scuzhangzhang.github.io/2017/11/05/hexo 博客恢复/</id>
    <published>2017-11-04T16:00:00.000Z</published>
    <updated>2017-11-05T05:38:26.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装node-js和git"><a href="#1-安装node-js和git" class="headerlink" title="1.安装node.js和git"></a>1.安装node.js和git</h3><p> 这个不用多说，直接下载安装就行了。</p><h3 id="2-配置-git-个人信息，生成新的-ssh-密钥："><a href="#2-配置-git-个人信息，生成新的-ssh-密钥：" class="headerlink" title="2.配置 git 个人信息，生成新的 ssh 密钥："></a>2.配置 git 个人信息，生成新的 ssh 密钥：</h3><p>git config –global user.name “xxxxxx”<br>git config –global user.email “xxxxxx”<br>ssh-keygen -t rsa -C “xxxxxxxx(邮箱)”</p><h3 id="3-添加公钥"><a href="#3-添加公钥" class="headerlink" title="3.添加公钥"></a>3.添加公钥</h3><p>在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。</p><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p>建议先<br>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a><br>安装的时候 用cpm 代替npm<br>这样的话npm 安装比较快而且不容易失败<br>cnpm install hexo-cli -g</p><h3 id="5-删除博客文件夹文件，保留部分"><a href="#5-删除博客文件夹文件，保留部分" class="headerlink" title="5.删除博客文件夹文件，保留部分"></a>5.删除博客文件夹文件，保留部分</h3><p>打开原来的博客文件夹,只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。</p><h3 id="6-git-bush"><a href="#6-git-bush" class="headerlink" title="6.git bush"></a>6.git bush</h3><p>在本文件夹下git bush,运行cnpm install</p><h3 id="7-安装部署插件"><a href="#7-安装部署插件" class="headerlink" title="7.安装部署插件"></a>7.安装部署插件</h3><p>npm install hexo-deployer-git –save</p><h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h3><p>此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装node-js和git&quot;&gt;&lt;a href=&quot;#1-安装node-js和git&quot; class=&quot;headerlink&quot; title=&quot;1.安装node.js和git&quot;&gt;&lt;/a&gt;1.安装node.js和git&lt;/h3&gt;&lt;p&gt; 这个不用多说，直接下载安装就行了。
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>对抗反汇编分析</title>
    <link href="http://scuzhangzhang.github.io/2017/10/22/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/"/>
    <id>http://scuzhangzhang.github.io/2017/10/22/对抗反汇编分析/</id>
    <published>2017-10-21T16:00:00.000Z</published>
    <updated>2017-10-25T12:17:26.608Z</updated>
    
    <content type="html"><![CDATA[<p>1.样本是恶意代码实战中的Lab15-03.exe。</p><p>2.IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。</p><p><img src="https://i.imgur.com/vd4KEI6.png" alt=""></p><p>2.由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit-&gt;Patch Program-&gt;change word ,把E9改为90，然后按c转换为代码就可以了。效果如图</p><p><img src="https://i.imgur.com/Qtl0ZFP.png" alt=""></p><p>继续往下看，发现有一个除零异常出现 ，</p><p><img src="https://i.imgur.com/ng6kIn0.png" alt=""></p><p>显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图</p><p><img src="https://i.imgur.com/d8PyGdS.png" alt=""></p><p>这个估计就是恶意代码真正要做的事情的代码了。继续向下看，有个URLDownloadToFileA函数，显然很恶意。下面还有个反汇编异常先处理了，先D后C，然后结果如下，</p><p><img src="https://i.imgur.com/0TKYBzh.png" alt=""></p><p>到此整个代码就分析完了，主要是4014c0处是真正要关注的，下面分析这个位置的代码</p><p><img src="https://i.imgur.com/KPoVtCC.png" alt=""><br><img src="https://i.imgur.com/ue6meMj.png" alt=""></p><p>主要关注标红的位置，此处看不出什么来，在OD中实际执行一下来看。</p><p>直接在0x40148c处下断点，然后直接f9运行到此处，若看到一堆数据，右键分析-&gt;从模块中删除分析就可以了，改写相应位置的异常按照IDA那样，实验过程发现se处理程序的确是0x4014c0但是程序并没有跳到那个位置而是终止了，没搞明白，为了真正看到0x4014c0处的具体执行情况。我选择直接编辑汇编代码。写入jmp 0x4014c0,</p><p><img src="https://i.imgur.com/kijEK2T.png" alt=""></p><p>发现在0x4014db处好像也是异常终止了，后改为</p><p><img src="https://i.imgur.com/yhPNUnh.png" alt=""></p><p>正常了、<br>然后在四个函数处下断点观察参数信息和返回信息，</p><p><img src="https://i.imgur.com/KK9LVGS.png" alt=""></p><p>0x401534明显是一个解密函数，然后把网址和文件就解密出来，然后URLDownloadToFileA下载，winexec 执行下载的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.样本是恶意代码实战中的Lab15-03.exe。&lt;/p&gt;
&lt;p&gt;2.IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://scuzhangzhang.github.io/2017/10/20/iptables/"/>
    <id>http://scuzhangzhang.github.io/2017/10/20/iptables/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-10-25T03:44:43.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。</p><p>&emsp;&emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。</p><p>&emsp;&emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw–&gt;mangle–&gt;nat–&gt;filter</p><p><img src="https://i.imgur.com/Fl0nfg8.png" alt=""></p><p><img src="https://i.imgur.com/OHQyUMC.png" alt=""></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>&amp;emsp常用操作命令    说明</p><p>-A    在指定链尾部添加规则</p><p>-D    删除匹配的规则</p><p>-R    替换匹配的规则</p><p>-I    在指定位置插入规则</p><pre><code>例：iptables -I INPUT 1 --dport 80 -j ACCEPT（将规则插入到filter表INPUT链中的第一位上）</code></pre><p>-L/S    列出指定链或所有链的规则</p><p>-F    删除指定链或所有链的规则</p><p>-N    创建用户自定义链</p><pre><code>例：iptables -N allowed</code></pre><p>-X    删除指定的用户自定义链</p><p>-P    为指定链设置默认规则策略，对自定义链不起作用</p><pre><code>例：iptables -P OUTPUT DROP</code></pre><p>-Z    将指定链或所有链的计数器清零</p><p>-E    更改自定义链的名称</p><pre><code>例：iptables -E allowed disallowed</code></pre><p>-n    ip地址和端口号以数字方式显示</p><pre><code>例：iptables -Ln</code></pre><p>常见规则匹配器    说明</p><p>-p tcp|udp|icmp|all    匹配协议，all会匹配所有协议</p><p>-s addr[/mask]    匹配源地址</p><p>-d addr[/mask]    匹配目标地址</p><p>–sport port1[:port2]    匹配源端口(可指定连续的端口）</p><p>–dport port1[:port2]    匹配目的端口(可指定连续的端口）</p><p>-o interface    匹配出口网卡，只适用FORWARD、POSTROUTING、OUTPUT。</p><pre><code>例：iptables -A FORWARD -o eth0</code></pre><p>-i interface    匹配入口网卡，只使用PREROUTING、INPUT、FORWARD。</p><p>–icmp-type     匹配icmp类型（使用iptables -p icmp -h可查看可用的ICMP类型<br>）</p><p>–tcp-flags mask comp    匹配TCP标记，mask表示检查范围，comp表示匹配mask中的哪些标记。</p><pre><code>例：iptables -A FORWARD -p tcp --tcp-flags ALL SYN，ACK -j ACCEPT（表示匹配SYN和ACK标记的数据包）</code></pre><p>目标动作    说明</p><p>ACCEPT    允许数据包通过</p><p>DROP    丢弃数据包</p><p>REJECT    丢弃数据包，并且将拒绝信息发送给发送方</p><p>SNAT    源地址转换（在nat表上）</p><pre><code>例：iptables -t nat -A POSTROUTING -d 192.168.0.102 -j SNAT --to 192.168.0.1 </code></pre><p>DNAT    目标地址转换（在nat表上）</p><pre><code>例：iptables -t nat -A PREROUTING -d 202.202.202.2 -j DNAT --to-destination 192.168.0.102</code></pre><p>REDIRECT    目标端口转换（在nat表上）</p><pre><code>例：iptables -t nat -D PREROUTING -p tcp --dport 8080 -i eth2.2 -j REDIRECT --to 80</code></pre><p>MARK    将数据包打上标记</p><pre><code>例：iptables -t mangle -A PREROUTING -s 192.168.1.3 -j MARK --set-mark 60</code></pre><h3 id="注意要点："><a href="#注意要点：" class="headerlink" title="注意要点："></a>注意要点：</h3><pre><code>1、目标地址转换一般在PREROUTING链上操作2、源地址转换一般在POSTROUTING链上操作</code></pre><p>state：匹配指定的状态数据包</p><p>参数    说明</p><p>–state value    value可以为NEW、RELATED（有关联的）、ESTABLISHED、INVALID（未知连接）</p><p>例子：<br>    iptables -A INPUT -m state –state NEW，ESTABLISHED -j ACCEPT</p><h2 id="常见iptables"><a href="#常见iptables" class="headerlink" title="常见iptables"></a>常见iptables</h2><p>&emsp;&emsp;MASQUERADE：是动态分配ip时用的IP伪装：在nat表的POSTROUTING链加入一条规则:所有从ppp0口送出的包会被伪装（MASQUERADE）</p><p> iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE</p><p>&emsp;&emsp;REDIRECT：重定向，这个在squid透明代理时肯定要用到它</p><p> 所有从eth1进入的请求80和82端口的数据，被转发到80端口，由squid处理。</p><p> iptables -t nat -A PREROUTING - -i eth1 -p tcp -m multiport –dports 80,82 -j REDIRECT –to-ports 80</p><p>保存和恢复iptables规则</p><p>使用iptables-save可以保存到特定文件中</p><p>&emsp;&emsp;iptables-save &gt;/etc/sysconfig/iptables_save</p><p>使用iptables-restore可以恢复规则</p><p>&emsp;&emsp;iptables-restore&lt;/etc/sysconfig/iptables_save</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发
      
    
    </summary>
    
      <category term="网络" scheme="http://scuzhangzhang.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://scuzhangzhang.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>双系统安装（win10+ubuntu）</title>
    <link href="http://scuzhangzhang.github.io/2017/10/16/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://scuzhangzhang.github.io/2017/10/16/双系统安装/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-11-05T04:46:32.813Z</updated>
    
    <content type="html"><![CDATA[<p>1.我选择的 是win10加ubuntu双系统。</p><p>2.准备工作</p><pre><code>U盘一个16gwin10系统ubuntu系统</code></pre><p>3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。</p><p>4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。</p><p>其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。/boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分/，15g-20g左右，剩下的可以全部给/home。引导驱动器选择/boot,然后继续安装正常方式来装就好了。</p><p>4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择/boot对应的就好了。此时重启你就会发现有两个候选操作系统了。</p><p><img src="https://i.imgur.com/prFcTXH.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.我选择的 是win10加ubuntu双系统。&lt;/p&gt;
&lt;p&gt;2.准备工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;U盘一个16g
win10系统
ubuntu系统
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>对抗反汇编</title>
    <link href="http://scuzhangzhang.github.io/2017/10/16/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>http://scuzhangzhang.github.io/2017/10/16/对抗反汇编/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-10-25T07:18:53.412Z</updated>
    
    <content type="html"><![CDATA[<p>1.插入流氓字节，阻止真正的指令被反汇编</p><blockquote><p>线性反汇编和面向代码流的反汇编：</p><p>线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如：</p></blockquote><pre><code>.text:00401035                 jz      short near ptr loc_401037+1.text:00401037.text:00401037 loc_401037:                             ; CODE XREF: .text:00401035j.text:00401037                 call    near ptr 8B4C55C7h</code></pre><blockquote><p>观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察</p><pre><code>                 xor     eax, eax.text:00401035                 jz      short loc_401038.text:00401035 ; ---------------------------------------------------------------------------.text:00401037                 db 0E8h.text:00401038 ; ---------------------------------------------------------------------------.text:00401038.text:00401038 loc_401038:                             ; CODE XREF: .text:00401035j.text:00401038                 mov     eax, [ebp+0Ch]</code></pre><p>这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。</p></blockquote><p>2.固定条件的跳转指令</p><pre><code>   xor     eax, eax.text:00401035                 jz      short loc_401038</code></pre><p>3.函数指针问题 </p><pre><code> mov [ebp+var_4],offset sub_4011c0; call [ebp+var_4]可用IDA脚本语言IDC进行修正函数为AddCodeXref();</code></pre><p>3.函数未识别的问题 </p><blockquote><p>可以按p键来强制把一段代码变成函数<br>但是要把流氓字节nop,不然函数可能会出问题。用IDA自带的patch program来做。<br>也可用脚本idapython  代码如下：</p></blockquote><pre><code>import idaapiidaapi.CompileLine(&apos;static n_key(){ RunPythonStatement(&quot;nopIt()&quot;);}&apos;)AddHotkey(&quot;Alt-N&quot;,&quot;n_key&quot;)def nopIt():    start=ScreenEA()    end=NextHead(start)    for ea in range(start,end):        PatchByte(ea,0x90)    Jump(end)</code></pre><p>4，异常触发</p><pre><code>push offset sub_4014c0push large dword ptr fs:0mov large fs:0,espxor ecx,ecxdiv ecx</code></pre><blockquote><p>属于滥用结构化异常（SEH）来对抗反汇编，通过人为构造一些比如访问一个无效的内存区域，除0等来触发异常，</p><p>SHE链是一个函数列表，处理线程的异常，列表中的函数要么处理异常，要么向下传递，如果传递到最后一个异常处理函数，就会被认为是一个不能处理的异常，弹出“an unhandled exception has occurred ”。</p><p>查找SEH链，操作系统会检查FS寄存器，这个寄存器中包含一个段选择子，从概念上来讲，链表以栈的方式工作，第一个调用的是最后一个加入链表的记录。前面的例子就是把自己的异常处理加入到链表的头部，然后用除0来触发异常，进而执行自己的代码。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.插入流氓字节，阻止真正的指令被反汇编&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线性反汇编和面向代码流的反汇编：&lt;/p&gt;
&lt;p&gt;线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
